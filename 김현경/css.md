## 반응형 웹의 3요소 🔥🔥

- 그리드 레이아웃
  - 레이아웃을 고정된 픽셀 대신 비율로 설정하여 화면 크기에 따라 콘텐츠가 유동적으로 배치된다.
- 가변형 이미지
  - 이미지 크기를 고정하지 않고 `max-width`, `width`, `min-width` 등을 이용해 화면 너비에 따라 높이와 너비가 바뀌도록 조정한다.
- 미디어 쿼리
  - `@media` 규칙을 사용하여 특정 화면 크기나 해상도에 따라 다른 스타일을 적용한다.

## CSS selector가 어떠한 원리로 동작하나요? 🔥

- 브라우저는 HTML을 파싱하여 DOM 트리를 생성하고, CSS 규칙을 각 요소에 적용한다.
- CSS 엔진은 **우선순위**에 따라 적용할 스타일을 결정한다.
- 이때 ID > 클래스 > 태그 > 유니버설 순으로 구체성이 높아질수록 우선 적용된다.
- 구체성이 같을 경우에는 가장 나중에 정의된 스타일이 적용된다.

### ID 선택자 (#id)

- `#header`, `#footer`처럼 ID 선택자는 HTML 요소의 id 속성에 매칭되는 요소를 선택

### 클래스 선택자 (.class)

- `.container`처럼 클래스 선택자는 HTML 요소의 class 속성에 매칭되는 요소를 선택

### 태그(요소) 선택자 (tag)

- `div`, `p`, `a`와 같이 HTML 태그 이름을 직접 사용하여 특정한 요소 타입 전체에 스타일을 적용

### 유니버설 선택자 (\*)

- `*` 선택자는 문서의 모든 요소를 선택

## 반응형웹과 적응형웹에 설명하시오 🔥

## 반응형 웹이란? 🔥

- 다양한 디바이스 환경에서 화면 크기에 맞춰 자동으로 레이아웃을 조정하는 웹 디자인 방식
- 즉, 단 하나의 웹 페이지를 만들어 모든 종류의 화면 크기와 장치에 자동으로 적용
- 유연한 그리드 레이아웃, 가변형 이미지, 미디어 쿼리를 통해 화면의 크기 변화에 따라 일관된 UI 제공

## 적응형 웹이란?

- 화면 크기별로 정해진 레이아웃을 여러 개를 만들어 특정 디바이스에서 최적화된 페이지를 제공하는 방식

## PX, EM에 대해 설명하시오 🔥🔥

- 절대단위
  - 화면 해상도나 부모 요소에 관계없이 고정된 크기
  - in, cm, mm, pt, pc
- 상대단위
  - 고정되지 않고 다른 요소나 컨텍스트에 비례하여 크기가 달라지는 유동적인 단위이다.
  - 반응형 디자인에 유용
  - em, rem, ex, px, %, vw, vh
- `px`
  - `px`는 고정된 절대 크기로, 정확한 크기 조절이 필요할 때 주로 사용
- `em`
  - `em`은 부모 요소의 폰트 크기를 기준으로 비례한다.
  - 폰트 크기나 `padding`, `margin`을 부모 요소에 비례하여 지정할 때 유용
  - 중첩된 요소에서 크기가 커질 수 있어 주의가 필요
- `rem`
  - 최상위 요소의 폰트 크기를 기준으로 비례한다.
  - `em`과 달리 중첩 영향을 받지 않아 일관된 비율을 유지하기 쉽다.
- `ex`
  - `ex`는 현재 폰트에서 소문자 `x`의 높이(`x-height`)를 기준으로 비례하는 단위이다.
  - 특정 텍스트 요소의 상대적인 크기 조절에 적합하다.
- `%`
  - `%`는 부모 요소의 크기에 비례하여 설정되는 단위이다.
  - 레이아웃이나 반응형 디자인에서 요소의 크기를 부모에 맞춰 유연하게 조정할 때 사용한다.
- `pt`
  - 일반 문서에서 많이 사용하는 단위이다.
  - 절대 단위로, 1pt는 1/72인치에 해당한다.

## CSS 적용 우선순위 🔥🔥

- `!important`가 선언된 스타일이 가장 우선순위가 높다.
- 선택자의 명시도가 높을 수록 우선 적용된다.
  - 인라인 스타일 (`style` 속성) > ID 선택자(`#id`) > 클래스 선택자(`.class`), 속성 선택자(`[attr]`), 의사 클래스(`:hover`) > 태그 선택자(`div`, `p`)
- 일반적으로 뒤에 나오는 css가 우선순위가 높다.
- 우선순위가 같다면 개수가 많은 css 가 더 높다.

## CSS-in-JS에 대해서 설명해 주세요. 🔥

- `CSS-in_JS`는 자바스크립트 코드에서 css를 작성하는 방식이다.
- 대표적인 라이브러리로 `styled-components`, `Emotion` 이 있다.

### 장점

- 유지보수 용이
  - CSS와 JavaScript가 결합되어 컴포넌트의 스타일을 컴포넌트 내에서 관리할 수 있어 수정과 재사용이 용이하다.
- 스타일 충돌 방지
  - 고유 클래스 네임이 자동 생성되어 다른 컴포넌트와의 스타일 충돌을 방지할 수 있다.
- 동적 스타일링과 스타일 확장
  - JavaScript 변수나 상태를 활용해 조건부 스타일링이 가능하며, 필요한 경우 컴포넌트 단위로 스타일을 상속받아 확장할 수 있다.
- 모듈성
  - CSS가 컴포넌트 레벨에서만 적용되기 때문에 진정한 분리 법칙을 따른다.
  - 컴포넌트 단위로만 스타일이 적용되므로 불필요한 스타일 확산을 방지할 수 있다.

### 단점

- 성능 이슈
  - 일반 CSS 파일보다 로딩 속도가 느릴 수 있다.
  - 복잡한 스타일이 많을 경우 렌더링에 영향을 줄 수 있다.
- 코드 길이 증가
- 자동 완성 문제
  - `styled-components`와 같은 라이브러리는 기본적으로 문자열로 CSS를 처리하여 에디터에서 CSS 자동 완성이 지원되지 않을 수 있다.

## CSS 전처리기(CSS preprocessors)를 사용해보셨나요? 🔥

CSS 전처리기는 전처리기가 가진 특별한 syntax으로 CSS를 생성하도록 하는 프로그램이다.

즉, CSS 전처리기는 CSS를 더 효율적으로 작성할 수 있도록 도와주는 도구다.

기존 CSS에 없는 변수, 조건문, 함수 등의 기능을 제공해 **코드 재사용성**을 높이고, 작성과 유지보수를 쉽게 해준다.

대표적인 전처리기로는 `Sass`, `LESS`, `Stylus`가 있다.

### 장점

- CSS 코드를 여러 파일로 나눠 유지보수성 향상
- 중첩 선택자를 작성하기 쉽다
- 일관된 테마를 위한 변수 사용
- 반복되는 CSS를 위한 믹스인(Mixins) 생성 가능 (재사용 가능)

Mixin은 재사용할 CSS 스타일을 정의할 수 있는 기능이다.

```
/* 선언 @mixin */

@mixin large-text {
  font-size: 22px;
  font-weight: bold;
}
h1 {
  @include large-text;
}
```

### 단점

- CSS와 다른 문법을 익혀야 한다.
- CSS로 컴파일하는 빌드 단계가 추가된다.
  - 이는 설정과 컴파일 시간이 필요하기 때문에 빌드 프로세스를 복잡하게 만들 수 있다.
- 디버깅이 어렵다.
  - 전처리기를 사용해 컴파일된 CSS 파일에는 원본 코드와 다른 부분이 있어, 디버깅이 어려울 수 있다.
  - source map 기능을 사용하면 어느 정도 해결이 가능하다.