# 프로그래밍 🔥

## 프로그래밍이란 뭐라고 생각하나요?

- 프로그래밍은 컴퓨터가 주어진 작업을 수행할 수 있도록 명령을 작성하는 과정이다.

## 컴파일러는 뭐고 인터프리터는 뭔가요?

### 컴파일러(Compiler)

- 프로그래밍 언어로 작성된 소스 코드를 기계어로 번역하는 프로그램

  ### 장점

  - 컴파일된 프로그램은 실행 시 번역이 필요없어 실행 속도가 빠르다.
  - 컴파일 단계에서 문법 오류를 모두 확인하고 실행 전에 오류를 고칠 수 있다.

  ### 단점

  - 소스 코드가 크면 컴파일 하는데 오래 걸린다.
  - 컴파일된 실행 파일은 특정 운영체제나 환경에 종속되어 다른 환경에서 재컴파일이 필요할 수 있다.
  - 디버깅이 어렵다.

### 인터프리터(Interpreter)

- 프로그래밍 언어로 작성된 코드를 **한 줄씩** 읽고 해석하여 즉시 실행하는 프로그램이다.

  ### 장점

  - 코드를 수정하고 바로 실행할 수 있어 코드 작성과 테스트가 빠르다.
  - 한 줄씩 실행하기 때문에 디버깅이 편리하다.
  - 특정 플랫폼에 종속되지 않아 여러 운영체제에서 동일하게 실행할 수 있다.

  ### 단점

  - 한 줄씩 번역하기 때문에 컴파일된 프로그램보다 실행 속도가 느리다.
  - 실행 전에 모든 오류를 확인할 수 없다.

# 자바스크립트란 🔥

- 자바스크립트는 동적인 웹페이지를 만들기 위한 프로그래밍 언어

## 자바스크립트의 특징은 뭐가 있나요?

### 가벼운 언어

- 자바스크립트는 경량 언어로 초기 로딩과 실행이 빠르다.

### 인터프리터 언어

- 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**

- **코드를 한 줄씩 해석하여 실행**

  대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합하여 처리 속도 최적화한다.

  - 인터프리터는 소스코드를 즉시 실행
  - JIT(Just-In-Time)컴파일러는 머신 코드를 생성하고 최적화

- 이런 방식 덕분에 실행 속도가 빨라서 빠른 피드백과 디버깅이 가능하다

  #### 모던 자바스크립트 엔진이란?

  - 최신 웹 브라우저와 js실행 환경에서 사용되는 고성능 자바스크립트 처리 엔진
  - 자바스크립트 코드를 효율적으로 해석, 컴파일, 실행하기 위해 설계되었고 빠른 실행 속도와 최적화를 지원
  - JIT 컴파일
    - 코드 실행 전 바이트코드로 컴파일하여 실행 속도 높임
    - 자주 실행되는 코드를 최적화하여 성능을 더 높이는 기술 사용
  - 가비지 컬렉션
    - 사용되지 않는 메모리를 자동으로 정리하여 효율적으로 메모리 관리
  - 멀티스레딩 지원
    - 백그라운드 작업을 위한 멀티스레딩 기술 사용하여 성능 향상
  - `V8(Google)`, `SpiderMonkey(Mozilla)`, `JavaScriptCore(WebKit)`, `Chakra(Microsoft)`

### 동적 타입 언어

- 변수의 데이터 타입이 고정되지 않고 실행 중 변경될 수 있다.

  ```
  let value = 5;
  value = "hello";
  ```

### 객체 기반 언어

- 모든 데이터가 객체로 표현될 수 있다.

### 프로토타입 기반 상속

- 자바스크립트는 클래스 기반 언어가 아닌 **프로토타입 기반 언어**이다.

### 멀티 패러다임 언어

- 객체 지향(OOP), 함수형(FP), 절차적 프로그래밍 모두 지원한다.

### 이벤트 기반 비동기 처리 지원

- callback, Promise, async/await 제공
- 이벤트 루프를 통해 효율적으로 비동기 작업 처리

### 브라우저와 플랫폼 독립적으로 동작

- 브라우저와 서버 모두에서 실행 가능

# 변수 🔥

## 변수란 무엇인가요?

- 데이터를 저장하기 위한 이름이 붙은 메모리 공간
- 즉, 값의 위치를 가리키는 상징적인 이름
- 변수는 언제든지 값이 바뀔 수 있다.
- 자바스크립트에서 변수는 선언 시 `호이스팅`이라는 메커니즘에 의해 코드의 상단으로 끌어올려진다.
  - **호이스팅(Hoisting)**: 변수 선언이 런타임 이전에 스코프의 최상단으로 끌어올려지는 자바스크립트의 동작 방식
  - `var`로 선언한 변수는 초기화 전에 접근 가능하며, 값은 `undefined`로 설정된다.
    - 이는 선언이 호이스팅되지만, 초기화가 실제 실행 시점에 이루어지기 때문
  - `let`과 `const`는 호이스팅되더라도 **초기화 이전에는 접근할 수 없다**. (일시적 사각지대, TDZ)

## 식별자란 무엇인가요? 🔥

- 식별자는 변수, 함수, 객체 등을 구별하기 위해 사용하는 이름
- 식별자는 값이 아니라 메모리 주소를 기억한다.

## 변수를 선언한다는 것은 어떤 것을 의미하나요?

- 데이터를 저장하기 위해 메모리 공간을 확보하고 확보된 메모리 공간의 주소와 변수 이름을 연결해서 값을 저장할 수 있게 하는 것을 의미한다.

  ```
  let a = 5;
  // a라는 이름으로 메모리 공간을 확보하고 해당 공간에 값 5를 저장
  ```

- `var`, `let`, `const`를 사용하여 변수를 선언한다.

## var 키워드는 뭔가요?

- `var` 키워드는 변수를 선언할 때 사용하는 것이다.
- ES6 이전까지는 변수를 선언하는 유일한 방법
- 과거에 브라우저 호환성 때문에 주로 사용되었다.
  - 현재는 `let`과 `const`가 도입되어 사용을 권장하지 않음

### var 특징

- 함수 스코프
  - var로 선언된 변수는 함수 내부 전체에서 유효
  - 블록 스코프를 지원하지 않아 블록`{}` 안에서 선언해도 블록 외부에서 접근 가능
- 변수 호이스팅
  - var로 선언된 변수는 함수 또는 스크립트의 최상단으로 끌어올려진 것처럼 동작
  - 하지만 초기화는 끌어올려지지 않는다.
- 중복 선언 가능

  - 동일한 이름으로 여러 번 변수를 선언해도 에러 발생 x

  ### 변수 선언 비교

  |                | `var`                                  | `let`                               | `const`                             |
  | -------------- | -------------------------------------- | ----------------------------------- | ----------------------------------- |
  | 스코프         | 함수 스코프                            | 블록 스코프                         | 블록 스코프                         |
  | 재선언         | 재선언 가능                            | 재선언 불가능                       | 재선언 불가능                       |
  | 초기화 전 접근 | 선언 전에 접근 가능 (`undefined` 반환) | 선언 전에 접근 불가(참조 에러 발생) | 선언 전에 접근 불가(참조 에러 발생) |
  | 값 변경        | 초기값 변경 가능                       | 초기값 변경 가능                    | 초기값 변경 불가(상수)              |

## 호이스팅이 뭔가요? 🔥🔥

- 호이스팅은 자바스크립트 엔진이 코드를 실행하기 전에 **변수나 함수 선언을 최상단으로 끌어올리는 동작**을 말한다.
- **변수 선언만 끌어올려지고 초기화는 원래 위치에서 수행**된다.
- 메모리 할당 측면에서, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하고, 값 할당은 실행 시점에 이루어진다.

예제1

```
console.log(score); // undefined
var score; // 변수 선언문
```

- 아직 score가 선언이 되지 않았을 때 score를 출력하면 인터프리터에 의해 참조 에러가 발생할 것처럼 보인다.
- 호이스팅 때문에 `undefined` 출력
- `undefined`가 출력되는 이유는 변수 선언이 코드가 한 줄씩 실행되는 시점(런타임 시점)이 아닌, 그 이전 단계에서 먼저 실행되기 때문이다.

예제2

```
console.log(x); // undefined (변수 선언은 끌어올려졌지만 초기화되지 않음)
var x = 5;
console.log(x); // 5
```

이 코드의 실제 실행 순서

```
var x;         // 선언이 호이스팅됨
console.log(x); // undefined
x = 5;         // 초기화는 원래 위치에서 수행됨
console.log(x); // 5
```

### `let`, `const`도 호이스팅이 발생하는가?

- `var`, `let`, `const` 모두 호이스팅 발생하지만 동작이 다르다.
- `var`는 선언과 동시에 초기화가 일어나서 참조 에러가 발생하지 않음
- `let`과 `const`는 선언이 된 후에 초기화가 일어나므로, 초기화 전에 참조하면 참조 에러 발생
  - 이를 **일시적 사각지대(TDZ)**라고 함

### 호이스팅 범위

- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용하는 모든 식별자는 호이스팅 된다.

## var 키워드의 문제점은 무엇이 있나요? 🔥

### 1. 변수 중복 선언 허용

- 동일한 변수명을 여러 번 선언해도 에러가 발생하지 않고 이전 값을 덮어씀
- 복잡한 코드에서 변수 관리 어려워질 수 있음
  ```
  var c = 5;
  var c = 10; // 에러 없이 덮어씀
  console.log(c); // 10
  ```

### 2. 함수 레벨 스코프(블록 레벨 스코프 미지원)

- `var`는 함수 스코프를 가진다.
- `{}` 블록 안에서 선언된 변수도 블록 외부에서 접근 가능하여 예기치 않은 동작이 발생할 수 있다.

  ```
  var a = 1; // a는 전역변수

  if (true) {
    var a = 10;
  }
  console.log(a); // 10 (블록 외부에서도 접근 가능)
  ```

### 3. 변수 호이스팅으로 인한 예측 불가능

- `var` 키워드로 선언된 변수는 호이스팅되어 선언 전에 접근이 가능하다.
- 위 호이스팅 설명에 있는 예제 참고

## let 키워드는 var 키워드와 어떤 점이 다른가요? 🔥🔥

### `let`

- 변수 중복 선언 x
- 재할당 가능
- 블록 레벨 스코프
- `let`은 호이스팅이 발생하지만, 선언 이전에 참조하면 참조 에러 발생

  - `var`는 선언문 이전에 참조하면 `undefined` 반환
  - `var`는 런타임 이전에 선언과 동시에 초기화되지만, `let`은 초기화 단계까지 변수를 참조할 수 없다.
  - 선언 단계부터 초기화 단계시작 전까지 해당 변수를 참조할 수 없으며, 이 구간을 `일시적 사각지대(TDZ)`라고 한다.

    <div style="display: flex; justify-content: space-around; align-items: center;">
      <img src="./images/let_const.png" alt="let/const_호이스팅" title="let/const" style="width: 45%; height: auto;">
      <img src="./images/var.png" alt="var_호이스팅" title="var" style="width: 45%; height: auto;">
    </div>

## const 키워드는 어떤 특징이 있나요? 🔥

### `const`

- 반드시 선언과 동시에 초기화해야 함
- 재선언, 재할당 금지 (단, 객체나 배열의 내용은 변경 가능)
- 블록 레벨 스코프
- `let`과 마찬가지로 호이스팅이 발생하지만, 선언 이전에 참조하면 참조 에러 발생

### 왜 const로 선언한 객체와 배열은 내용 변경이 가능한가?

- const는 변수 자체를 불변으로 만드는 것이 아니라 변수의 참조 주소 변경을 막는 것이기 때문이다.
- 객체나 배열은 **참조형 데이터**로, 변수에는 값 자체가 아니라 메모리 주소가 저장된다.
- 따라서 const로 선언된 변수는 주소 변경은 불가능하지만, 주소가 가리키는 객체나 배열의 내용 수정은 가능하다.

## TDZ 🔥🔥

- 일시적 사각지대
- 변수 선언은 되었지만 초기화가 단계가 시작되기 전까지의 구간을 의미
- TDZ 동안 변수를 사용할 수 없고 초기화 시점부터 참조 가능
- 선언 → TDZ → 초기화 → 할당

### 변수 선언, 초기화, 할당의 차이점

- **변수 선언**: 변수를 생성하는 것을 의미

  - 해당 식별자를 스코프에 등록하여 나중에 참조할 수 있도록 함

- **초기화**: 메모리에 변수 저장을 위한 공간을 확보하는 단계
- 이때 변수는 기본값으로 `undefined`가 할당

- **할당**: 변수에 실제 값을 할당하는 단계
  - `=` 연산자를 사용하여 값을 할당
  - 초기값이 `undefined`인 경우 실제 값을 할당해주는 단계

## 식별자 네이밍 규칙은 어떤 것들이 있나요?

- 특수문자를 제외한 **문자, 숫자, 언더스코어(`_`), `$`**만 사용가능하다.
- 숫자로 시작할 수 없다.
- 대소문자 구분이 가능하다.
- 예약어는 사용할 수 없다. (`await`, `break`, `class`, `for`, `if`, `this` 등)
  - 예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어

## 네이밍 컨벤션은 어떤 것들이 있나요?

네이밍 컨벤션은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 규칙

```
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

- 헝가리언 케이스는 타입을 변수명 앞에 붙여 타입을 명시하는 방식

## 리터럴이 뭔가요?

- 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.
- 즉, 값을 직접 표현한 것이다.
- 숫자, 문자열, 배열, 객체, 불리언, null 등
- 리터럴은 값 자체를 표현한 것으로 변수나 상수에 할당할 수 있는 값이다.

### 상수와 리터럴 차이

- 상수는 값을 변경할 수 없는 메모리 공간을 나타내며, 선언 후 메모리 값을 변경할 수 없다.
- 리터럴은 특정 값을 직접 표현한 것으로 변수나 상수에 할당될 수 있고, 메모리 안에 저장된다.

# 데이터 타입 🔥

- 데이터 타입은 값의 종류를 의미
- 원시 타입과 객체 타입으로 분류할 수 있다.
- **저장 가능한 메모리 크기**

## 원시 타입과 객체 타입의 차이점

| **항목**        | **원시 타입**                       | **객체 타입**                      |
| --------------- | ----------------------------------- | ---------------------------------- |
| **특성**        | 값 자체를 저장                      | 참조를 저장                        |
| **저장 위치**   | 스택                                | 힙                                 |
| **복사 방식**   | 값 자체가 복사                      | 참조(주소)가 복사                  |
| **변경 가능성** | 불변성                              | 가변성                             |
| **용도**        | 숫자, 문자열, 논리값 등 단순 데이터 | 복잡한 데이터 구조 (객체, 배열 등) |

### 💡핵심 차이

- 원시 타입은 값을 변경할 수 없으며, 새 값이 저장되면 기존 값은 **새 메모리 공간에 저장**된다.
- 객체 타입은 동적으로 크기가 변하며, 변수는 객체의 **주소(참조 값)만 저장**한다.

## 데이터 타입의 종류는 어떤 것들이 있나요? 🔥

### 원시 타입

#### 1. 숫자 타입

- 정수와 소수를 포함한 숫자 표현
- 자바스크립트에서는 모든 수를 64비트 부동소수점 형식으로 처리 (정수 타입 없음)
- 2진수, 8진수, 16진수도 표현 가능하지만 모두 10진수로 해석된다.

#### 2. 문자열 타입

- 문자들의 집합. 변경 불가능한 값
- 큰따옴표, 작은따옴표, 백틱으로 감싸서 표현
- 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현 가능
- **왜 따옴표로 감싸는가?**
  - 따옴표를 사용하지 않으면 식별자로 인식할 수 있기 때문이다.

#### 3. 불리언 타입

- 논리적 참, 거짓

#### 4. undefined 타입

- 값이 할당되지 않은 변수를 나타냄
- var로 선언된 변수에 암묵적으로 undefined로 초기화
- 변수를 선언한 이후 값을 할당하지 않은 변수를 참조할 때도 undefined가 반환

#### 5. null 타입

- 값이 없음을 명시적으로 표현
- **객체가 존재하지 않음**을 나타낼 때 사용

#### 6. 심벌 타입

- ES6에서 추가된 7번째 타입
- 고유하고 변경 불가능한 값을 표현
- 다른 값과 중복되지 않는 유일무이한 값
- 주로 객체의 속성의 유일한 키로 사용
  - 같은 값으로 생성해도 서로 다른 고유 값을 가짐

#### 7. BigInt 타입

- 임의 정밀도로 정수를 나타낼 수 있는 숫자 원시 값 즉, 임의의 크기를 가진 정수를 표현
- 큰 정수도 안전하게 저장하고 연산할 수 있음
- 숫자 뒤에 n을 붙여 사용

### 객체 타입

- 객체
  - 키-값 쌍으로 이루어진 데이터 구조
- 배열
  - 순서가 있는 리스트 형태의 데이터 구조
- 함수
  - 재사용 가능한 코드 블록으로 객체의 한 종류

💡 **`undefined`는 값이 없음을 의미하고, `null`은 객체가 없음을 의미한다.**

## 심벌 타입은 뭐죠?

- ES6에서 도입된 고유하고 변경 불가능한 원시 데이터 타입
- 주로 객체 속성 키로 사용되며, 속성 충돌을 방지

### 특징

#### 1. 항상 유일한 값

- 심벌로 생성된 값은 동일한 설명이 있어도 절대 중복되지 않음

  ```
  const sym1 = Symbol('desc');
  const sym2 = Symbol('desc');
  console.log(sym1 === sym2); // false
  ```

#### 2. 객체 속성의 유일한 키로 사용 가능

- 객체의 유일한 속성 키로 사용 가능성
- 다른 키와 충돌하지 않음

#### 3. 자동 타입 변환 제한

- 암묵적 타입 변환 불가

  - 문자열이나 숫자로 변환되지 않음 → 고유한 심벌 값이 의도치 않게 훼손되는 것을 방지

  ```
  console.log('My symbol: ' + Symbol('desc')); // TypeError
  ```

- 명시적 변환 가능

  - 문자열로 변환하려면 `String()` 또는 `toString()` 메서드 사용

  ```
  const sym = Symbol('desc');
  console.log(String(sym)); // Symbol(desc)
  ```

#### 4. 심벌은 열거되지 않음

- `for...in`, `Object.keys()`, `getOwnPropertyNames()`로 접근할 수 없다.
- `Object.getOwnPropertySymbols()`로 확인 가능하다.

### 왜 사용하는가?

- 객체 속성 충돌 방지
  - 다른 사람이 만든 코드랑 겹칠 걱정 없음
- 기존 코드에 영향을 주지 않고 확장 가능
  - 외부 코드와 독립적인 속성을 추가할 때 유용
  - 안전하게 확장 가능

## 데이터 타입은 왜 필요할까요? 🔥

### 값을 저장할 때 필요한 메모리 공간의 크기를 결정하기 위해

- ex) 숫자형은 8바이트, 문자열은 문자 수에 따라 가변적인 크기를 가짐 → 이를 통해 메모리 사용을 최적화할 수 있음

### 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해

- ex) 숫자는 한 번에 8바이트를 읽고 처리, 문자열이나 객체는 그 크기에 맞춰 더 많은 메모리 공간을 읽어야 할 수 있음

### 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

- ex) `Number`는 숫자로 해석, `String`은 문자로 해석하는데 이는 값이 메모리에서 읽어질 때 어떤 방식으로 처리될지 정의

## 정적 타이핑이 뭔가요?

- 정적 타이핑은 변수의 타입이 **컴파일 시점**에 결정되는 방식
- 변수에 타입을 선언하고, 한 번 타입이 정해지면 다른 타입의 값을 할당할 수 없다.
- 정적 타이핑 언어에서는 변수의 타입을 선언하고 타입이 일치하지 않으면 컴파일 오류 발생
- ex) C, JAVA, TypeScript

```
int var = 10;
String str = 'Hello';
```

### 장점

- 오류를 미리 잡을 수 있어 코드 안정성과 예측 가능성이 높아짐
- 타입 정보가 명확하여 코드 가독성이 좋음
- 컴파일 시점에 타입이 확정되어 코드 최적화가 용이

### 단점

- 유연성이 떨어짐
- 타입을 변경해야 할 경우, 타입을 명시적으로 수정해야 함

## 동적 타이핑이 뭔가요?

- 동적 타이핑은 변수의 타입이 **실행 시점**에 결정되는 방식
- 변수 선언 시 타입을 명시하지 않으며, 값이 할당될 때 자바스크립트 엔진이 해당 값에 맞는 타입을 자동으로 할당함
- 변수의 타입은 할당된 값에 따라 동적으로 결정됨
- ex) JavaScript, Python

### 장점

- 코드 작성이 빠르고 유연하며, 변수의 타입을 명시하지 않아 코드가 간결함
- 타입 선언이 불필요하여 개발 속도가 빠르다.

### 단점

- 실행 시점에 타입 오류가 발생할 수 있어 런타임에서 버그가 발생할 가능성이 있다.
- 코드의 예측 가능성이 떨어지며, 잘못된 타입이 할당되면 의도치 않은 동작이 발생할 수 있다.

# 타입변환과 단축 평가 🔥

## 명시적 타입 변환이 뭔가요?

- 개발자가 직접 코드로 데이터 타입을 변환하는 것을 의미한다.
- 타입 캐스팅이라고도 함
- 변환이 명확하게 드러나므로, 코드의 가독성이 높아진다.

## 명시적 타입 변환 함수를 예를 들어볼 수 있나요?

- 표준 빌트인 생성자 함수 사용

  - `Number()`, `String()`, `Boolean()` 같음 함수에 `new` 없이 호출하면 타입 변화 가능

- 메서드로 타입 변환
  - `toString()`, `parseInt()`, `parseFloat()`
- 예제

  ```
  // 표준 빌트인 생성자 함수 사용
  Number("123");     // 123
  String(42);        // "42"
  Boolean(0);        // false

  // 메서드로 타입 변환
  (123).toString();  // "123"
  parseInt("42px");  // 42
  parseFloat("3.14"); // 3.14
  ```

## 암묵적 타입 변환이 뭔가요?

- 암묵적 타입 변환은 개발자가 명시적으로 타입을 변환하지 않아도 자바스크립트 엔진이 코드 문맥에 따라 데이터 타입을 자동으로 변환하는 것
- 타입 강제라고도 함
  ```
  console.log(1 + '2'); // "12"
  ```

## truthy / falsy 한 값이 뭔가요?

자바스크립트에서 Boolean 타입으로 암묵적 변환이 일어날 때, 참(True)처럼 간주되는 값과 거짓(False)처럼 간주되는 값을 각각 Truthy 값과 Falsy 값이라고 한다.

- Truthy
  - Falsy 값이 아닌 모든 값
  - 숫자 1, 빈 배열 [], 빈 객체 {}, 문자열, Infinity
- Falsy
  - null, undefined, false, NaN, 0, -0, 0n, ""(빈 문자열), document.all

# 배열 🔥

## 자바스크립트의 배열은 자료구조의 배열과 같나요?

다르다.

### 자료구조의 배열

- 배열의 크기가 미리 정해져 있고 초기화 후에는 변경할 수 없다.
  - 요소를 추가하거나 제거하려면 새 배열을 만들어야 함
- 배열의 요소는 동일한 데이터 타입이어야 함
- 배열은 메모리상에서 연속적으로 배치된다.
  - 인덱스를 이용해 빠른 접근 가능

### 자바스크립트의 배열

- 배열의 크기가 동적으로 변하고 요소를 추가하거나 제거할 수 있음
- 배열에 서로 다른 데이터 타입의 요소를 저장할 수 있음
- 배열의 요소 중 일부가 비어있어도 배열로 취급 → **희소 배열**
- 배열은 **객체처럼 동작**, 요소가 연속적으로 배치되지 않을 수 있음
  - 인덱스 기반 접근이 느릴 수 있음

### 자바스크립트 배열은 객체인데 어떻게 `length`를 사용할 수 있나?

- 자바스크립트에서 배열은 기본적으로 객체로, 배열의 요소에 접근할 때 숫자 인덱스를 사용하지만 실제로는 이 숫자 인덱스가 문자열 키로 처리된다.
  - ex. `arr[0]`은 내부적으로 `arr['0']`으로 저장된다.
- 자바스크립트 배열은 일반 객체와 달리 숫자 인덱스를 사용하면 자동으로 `length`속성을 관리한다.
  - 자바스크립트 엔진이 배열의 숫자 인덱스를 감지하고 길이를 추적하도록 설계되었기 때문

## 배열의 메서드는 어떤 종류가 있나요?

### 1. 원본 배열을 직접 변경하는 메서드

<aside>

- **`push()`**: 배열의 끝에 하나 이상의 요소를 추가
- **`pop()`**: 배열의 마지막 요소를 제거
- **`shift()`**: 배열의 첫 번째 요소를 제거
- **`unshift()`**: 배열의 앞에 하나 이상의 요소를 추가
- **`reverse()`**: 배열의 순서를 반대로 변경
- **`sort()`**: 배열의 요소를 정렬
- **`splice()`**: 배열의 특정 위치에서 요소를 제거하거나 추가
- **`fill()`**: 배열의 지정된 범위에 특정 값을 채워넣음

</aside>

### 2 원본 배열을 변경하지 않고 새로운 배열을 반환하는 메서드

<aside>

- **`slice()`**: 배열의 일부를 잘라내어 새로운 배열로 반환
- **`concat()`**: 배열을 다른 배열과 결합하여 새로운 배열로 반환
- **`join()`**: 배열의 요소들을 문자열로 결합하여 반환
- **`includes()`**: 배열에 특정 값이 포함되어 있는지 여부를 반환 (배열 변경 X)
- **`indexOf()` / `lastIndexOf()`**: 특정 요소의 인덱스를 반환

</aside>

## 고차 함수에 대해서 아나요?

- 함수를 인수로 전달받거나 함수를 반환하는 함수를 의미
- 고차 함수는 배열 요소를 효율적으로 조작하거나 처리할 때 주로 사용됨

<aside>

- **`forEach()`**: 배열의 각 요소에 대해 함수를 실행 (반환값 없음)
- **`map()`**: 배열의 각 요소를 변환하여 새로운 배열 생성
- **`filter()`**: 조건에 맞는 요소들만 새로운 배열로 반환
- **`reduce()`**: 배열을 누적하여 단일 값 반환
- **`some()`**: 배열의 일부 요소가 조건을 만족하면 true 반환
- **`every()`**: 배열의 모든 요소가 조건을 만족하면 true 반환
- **`find()`**: 조건에 맞는 첫 번째 요소 반환
- **`findIndex()`**: 조건에 맞는 첫 번째 요소의 인덱스 반환

</aside>

## forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?

### `forEach`

- 원본 배열을 변경하지 않음
- 배열의 각 요소에 대해 작업을 수행
- 반환 값이 없음
- 주로 사이드 이펙트(ex. 콘솔 출력, 외부 상태 변경)에 사용됨

### `map`

- 원본 배열을 변경하지 않음
- 배열의 각 요소를 변환하여 새로운 배열을 생성
- 새로운 배열을 생성하기 때문에 반환 값이 있음
- `forEach`보다 빠름 (단, 브라우저 환경에 따라 다를 수 있음)

# 객체 리터럴 🔥

## 자바스크립트에서 객체란 뭘까요?

- 객체는 0개 이상의 프로퍼티로 구성된 집합이다.
  - 프로퍼티는 키와 값으로 구성되어 있다.
- 원시 값을 제외한 나머지 값은 모두 객체다.
  - 배열, 함수, 객체 리터럴, 정규표현식 등
- 객체는 변경 가능한 값이다.

## 함수와 메서드의 차이점에 대해 알고 계신가요?

### 함수

- 독립적으로 동작하는 코드 블록
- 객체에 속하지 않고 전역 스코프나 특정 스코프 내에서 정의되고 객체와 관계없이 동작
- 호출 대상이 없고 단순히 특정 작업을 수행하기 위해 사용

### 메서드

- 객체의 프로퍼티(속성)으로 정의된 함수
- 객체와 연관된 동작을 수행하고 객체의 프로퍼티를 참조하거나 조작할 수 있음
- 자신을 호출한 객체를 기반으로 동작하고, `this` 키워드를 사용하여 호출한 객체를 참조할 수 있음

## 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?

1. 객체 리터럴
2. `Object` 생성자
3. 생성자 함수
4. 클래스
5. `Object.create()`
6. JSON으로 객체 생성

# 원시 값과 객체 비교 🔥

## 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요?

- 메모리를 효율적으로 사용하기 위해

  - 원시 타입은 숫자, 문자열처럼 단순한 데이터를 다루고 값을 직접 저장해 빠르고 적은 메모리를 사용한다.
  - 참조 타입은 객체, 배열처럼 복잡한 데이터를 다룰 때 **주소(참조값)**를 저장해 큰 데이터를 유연하게 관리한다.

- 데이터 처리 방식을 최적화하기 위해

  - 원시 타입은 값을 복사해서 사용한다.
  - 참조 타입은 데이터 위치(참조값)를 공유한다.

요약: 저장 방식과 데이터 접근 방식이 다르기 때문에 타입을 나눔

## 값에 의한 전달이 뭔가요?

- 원시 타입 데이터를 변수에 할당하거나 다른 변수에 복사할 때 값 자체가 복사되어 각 변수가 독립적인 메모리 공간을 가진다.
- 한 변수의 값을 변경해도 다른 변수에는 영향을 주지 않음

## 참조에 의한 전달이 뭔가요?

- 참조 타입 데이터를 변수에 할당하거나 다른 변수에 복사할 때 참조값이 복사되어 모든 변수가 같은 메모리 주소를 참조하게 된다.
- 한 변수에서 값을 변경하면 모든 변수에 영향을 미치게 된다.

# 함수 🔥

- 특정 작업을 수행하는 코드의 일련의 명령문을 하나의 실행 단위로 묶은 것
- 재사용성, 가독성, 유지보수성을 높일 수 있음

## 자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?

- 함수 선언문

  - `function` 키워드 사용하여 선언
  - 호이스팅이 적용되어 함수 선언 전에 호출이 가능

  ```
  function add(x, y) {
    return x + y;
  }
  ```

- 함수 표현식

  - 함수가 변수에 할당되어 표현된다.
  - 호이스팅이 적용되지 않아서 선언 이후에만 호출이 가능

  ```
  var add = function (x, y) {
    return x + y;
  }
  ```

- Function 생성자 함수

  - `Function` 객체를 사용하여 동적으로 함수를 생성
  - 런타임 시 문자열로 함수를 정의하므로 성능상 불리하고 보안상 권장되지 않음

  ```
  var add = new Function('x', 'y', 'return x + y');
  ```

- 화살표 함수(ES6)
  - `=>` 문법을 사용해 간결한 함수 표현식 작성할 수 있음
  - `this`가 정적으로 바인딩되어 기존 함수와는 약간 다른 동작을 함
  - 호이스팅되지 않음
  ```
  var add = (x, y) => x + y;
  ```

## 함수 선언문과 함수 표현식은 어떤 차이가 있나요?

### 함수 선언문

- 독립된 선언문으로 간주되어 코드 실행 전에 선언과 정의가 모두 처리된다.
- 코드가 실행되기 전(컴파일 단계)에 함수가 메모리에 바로 등록되기 때문에 호이스팅되고 선언 전에 호출할 수 있다.

### 함수 표현식

- 변수에 함수를 할당하는 형태로, 변수 선언 자체는 호이스팅되지만 초기화는 해당 코드 줄에 도달했을 때 이루어진다.
- 따라서 함수 표현식은 호이스팅이 되지만 초기화 전에 호출하면 오류가 발생한다.
- 함수 표현식은 클로저와 함께 사용되어 정의된 범위의 변수 상태를 유지할 수 있다.

#### 클로저란?

- 함수가 선언된 시점의 외부 변수에 접근할 수 있는 함수를 의미
- 클로저를 통해 함수 내부에서 외부 상태를 기억해 데이터를 유지할 수 있음

```
// 함수 선언문
console.log(add(2, 3)); // 5 (호이스팅 적용)
function add(x, y) {
  return x + y;
}

// 함수 표현식
console.log(sub(5, 3)); // ReferenceError
const sub = function (x, y) {
  return x - y;
};
```

#### 요약

- 함수 선언문: **선언과 정의가 함께 호이스팅**되어 선언 전에 호출 가능
- 함수 표현식: 변수에 할당하기 때문에 변수 호이스팅 규칙을 따라 선언 후에만 호출 가능 (초기화 전에는 참조할 수 없음)

## 즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요

- 즉시 실행 함수(IIFE)는 정의와 동시에 실행되는 함수다.
- IIFE는 단 한 번만 호출되며 다시 호출할 수 없다.
- 익명 함수를 사용하는 것이 일반적이다.
  - 기명 함수도 사용할 수 있지만 다시 호출할 수 없기 때문에 함수 이름이 필요하지 않다.
- 반드시 `그룹 연산자 ()`로 함수를 감싸야 한다.

  - 함수 선언문과 함수 표현식은 다르게 처리되고, IIFE 함수는 함수 표현식이기 때문에 그룹 연산자로 감싸서 함수가 실행될 수 있도록 해야한다.

  ```
  // 즉시실행함수 IIFE
  (function() {
    alert("함수를 괄호로 둘러싸기");
  })();

  (function() {
    alert("전체를 괄호로 둘러싸기");
  }());

  !function() {
    alert("표현식 앞에 비트 NOT 연산자 붙이기");
  }();

  +function() {
    alert("표현식 앞에 단항 덧셈 연산자 붙이기");
  }();
  ```

### 즉시 실행 함수를 왜 사용하는가?

- 전역 변수 오염 방지
  - IIFE 내부에서만 변수를 사용할 수 있어 전역 변수를 보호함
- 스코프 격리
  - 외부에서 접근할 수 없는 지역 변수를 사용할 수 있음
- 초기화 코드 실행
  - 특정 작업을 코드의 상단에서 즉시 실행할 때 유용

# 스코프 🔥

## 스코프가 뭔가요? 🔥🔥🔥

- 스코프는 식별자가 유효한 범위를 의미한다.
  - 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다.
  - 유효 범위는 특정 코드 블록 안에서 해당 식별자가 접근 가능한지 결정
- 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 함
  - 엔진은 현재 스코프부터 상위 스코프를 순차적으로 탐색하는데 이것을 **스코프 체인**이라고 함

## 스코프에는 어떤 종류가 있죠? 🔥🔥

- 전역 스코프와 지역 스코프가 있다.

### 전역 스코프

- 자바스크립트 코드의 최상위 레벨에 해당하는 스코프 함수
- 코드 어디에서든 접근이 가능
- 전역 스코프에 선언된 변수는 전역 객체(window, globalThis)의 프로퍼티로 등록됨

### 지역 스코프

- 특정 코드 블록이나 함수 내부에서만 유효한 스코프
  - 블록 스코프: `{}`로 감싸진 블록 내에서만 유효
    - `let`, `const`
  - 함수 스코프: 함수 내에서만 유효
    - `var`
- 즉, 해당 함수 자신과 하위 함수에서만 자원에 접근이 가능
- 지역 스코프는 전역 스코프보다 우선순위가 높다.

## 렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요? 🔥

- 렉시컬 스코프는 **함수가 선언된 위치**에 따라 상위 스코프가 결정되는 방식
  - 자바스크립트는 렉시컬 스코프 방식을 따르기 때문에 함수가 실행되는 시점이 아니라 **선언된 시점**의 스코프 체인을 따른다.

### 렉시컬 스코프, 동적 스코프 요약

- 렉시컬 스코프: 선언된 위치 기준으로 상위 스코프 결정
- 동적 스코프: 호출된 시점 기준으로 상위 스코프 결정 (자바스크립트에서 사용 x)

### 스코프 체인이란?

- 식별자를 검색할 때 사용하는 연결된 스코프의 체계
- 자바스크립트 엔진은 현재 스코프에서 시작해 상위 스코프로 순차적으로 식별자를 검색한다.
- 검색 순서: 현재 스코프 → 상위 스코프 → 전역 스코프
- 검색 도중 식별자가 발견되면 검색을 중단하고 해당 값을 반환

```
var x = 1; // 전역 변수 x 선언

function foo() {
  var x = 10; // foo 함수의 지역 변수 x 선언
  bar(); // bar 함수 호출
}

function bar() {
  console.log(x); // x를 참조
}

foo(); // 1
// 렉시컬 스코프를 따르기 때문에 foo 내부에서 호출되어도 자신의 상위 스코프가 foo가 되지 않음
bar(); // 1

```

## 전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?

- 암묵적 결합과 의도치 않은 상태 변경

  - 전역 변수는 코드 어디에서나 참조 및 변경 가능해 변수 충돌 위험이 있다.
  - `var` 키워드로 선언된 전역 변수는 중복 선언이 가능해 예상치 못한 값 덮어쓰기가 발생할 수 있다.
  - 코드 간 결합도가 높아지고 유지보수가 어려움

- 긴 생명 주기 및 메모리 누수

  - 전역 변수는 프로그램이 종료될 때까지 메모리에 남아 있어 메모리 누수 가능성이 높다.
  - 상태 변경 시간이 길어 예기치 않은 동작이 발생할 수 있다.

- 검색 속도 저하

  - 전역 변수는 스코프 체인에서 가장 마지막에 검색돼 성능이 저하될 수 있다.

- 네임스페이스 오염
  - 모든 파일이 전역 스코프를 공유하기 때문에 동일한 이름의 변수 충돌로 예상치 못한 오류가 발생할 수 있다.

# 생성자 함수에 의한 객체 생성 🔥

## 생성자 함수가 뭔가요?

- `new` 연산자와 함께 호출하여 객체를 생성하는 함수이다.
- 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.
- 생성자 함수 이름은 첫 글자를 대문자로 작성한다. (파스칼 케이스)

### 추가로 알아두면 좋을 것

- 빌트인 생성자 함수: `Object` 생성자 함수 이외에도 `String`, `Number`, `Boolean`, `Function`, `Array`, `Date`, `RegExp`, `Promise`등을 제공
- `Object`, `Function` 생성자 함수는 `new` 연산자 없이 호출해도 `new` 연산자와 함께 호출했을 때랑 동일
- `String`, `Number`, `Boolean`은 `new` 연산자 붙히지 않으면 문자열, 숫자, 불리언 값으로 반환

## 객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요?

### 객체 리터럴

- 단일 객체 생성에 적합
- **동일한 프로퍼티 구조를 가진 객체를 여러 개 생성해야 하는 경우, 매번 프로퍼티를 반복해서 작성해야 하므로 비효율적이다.**

```
const person1 = { name: "Alice", age: 25 };
const person2 = { name: "Bob", age: 30 }; // 비슷한 구조를 반복
```

### 생성자 함수

- **동일한 구조를 가진 여러 객체를 효율적으로 생성할 수 있음** → 생성자 함수를 사용하는 이유
- 코드 중복을 줄이고 재사용성 높음

```
function Person(name, age) {
    this.name = name;
    this.age = age;
}

const person1 = new Person("Alice", 25);
const person2 = new Person("Bob", 30);

```

## 생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?

1. 빈 객체 생성

   - 생성자 함수 내부에서 사용할 빈 객체가 자동으로 생성
   - 이 객체는 생성자 함수의 프로토타입과 연결됨 (즉, 인스턴스)

2. `this` 바인딩

   - 생성된 빈 객체가 `this`에 바인딩 됨
   - 생성자 함수 내부에서 `this`를 통해 객체에 프로퍼티를 추가

3. 인스턴스 초기화

   - 생성자 함수가 실행되면서 `this`에 바인딩된 인스턴스에 프로퍼티와 메서드가 추가
   - 전달받은 인수를 사용하여 인스턴스의 값을 초기화

4. 암묵적 반환
   - 생성된 인스턴스가 바인딩된 **`this`가 암묵적으로 반환**
   - 단, 생성자 함수 내부에서 명시적으로 객체를 반환하면 해당 객체가 반환되고, 원시 값을 반환할 경우 무시되고 `this`가 반환
   - 따라서, 생성자 함수에서는 return문을 생략하는 것이 일반적

```
function User(name) {
  // this = {};  (빈 객체가 암시적으로 만들어짐)
  // 생성된 빈 객체가 this에 바인딩 됨

  // 새로운 프로퍼티를 생성된 객체(this)에 추가하고 초기화
  this.name = name; // 전달받은 name을 name 프로퍼티로 설정
  this.isAdmin = false; // isAdmin 프로퍼티를 false로 설정

  // return this;  (this가 암시적으로 반환됨)
}

let user = new User("보라"); // 새로운 User 인스턴스 생성

```

# 함수와 일급 객체 🔥

## 일급 객체가 뭔가요?

- 무명의 리터럴로 생성할 수 있다. (함수 이름 없이)
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

이러한 조건을 만족하는 객체를 일급 객체라고 한다.

자바스크립트에서 함수는 일급 객체이므로, 런타임에 동적으로 생성하고 다른 함수의 인자로 전달하거나 반환값으로 사용할 수 있다.

이것을 통해 함수형 프로그래밍이 가능해진다.

## 자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?

- 고차함수를 만들 수 있다.
  - 함수를 매개변수로 전달하거나 반환하는 함수
- 콜백을 사용할 수 있다.
  - 함수가 다른 함수에 인자로 전달되어 특정 시점에 호출됨

## 꼬리 질문) 함수형 프로그래밍이 뭔가요? 🔥🔥

- 함수형 프로그래밍은 순수 함수를 통해서 부수 효과를 줄여 오류를 피하고 프로그램의 안정성을 높이는 프로그래밍 패러타임이다.

## 꼬리 질문) 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있죠? 🔥🔥

### 일반 함수

- 일반 함수는 순수 함수와 비순수 함수를 모두 포함하는 넓은 개념
- 모든 함수는 일반 함수이며 순수성 여부에 따라 순수, 비순수 함수로 나뉨

### 순수 함수

- 순수 함수는 부수 효과가 없는 함수다.
- 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수를 내부로 전달된 인수에게만 의존해 값을 생성해 반환한다.
- 동일한 입력값에 대해 항상 동일한 결과 반환
- 불변성 유지
  - 함수 내부에서 전달받은 인자를 변경하지 않음

### 비순수 함수

- 비순수 함수는 외부 상태를 변경하거나 외부 상태에 의존하여 동작하는 함수
- 부수 효과를 가지며 실행 결과가 외부 요인에 따라 달라질 수 있어 예측 가능성이 떨어진다.
- 전역 변수, 객체 속성 등을 변경하거나 외부 환경(파일, 네트워크)과 상호작용하면 비순수 함수이다.

### 파라미터, 인수란?

`파라미터(Parameter)`

- 함수를 정의할 때 함수가 입력으로 받을 값을 가리키는 이름

`인수(Argument)`

- 함수를 호출할 때 실제로 전달하는 값
- 파라미터에 대입되어 함수 내부에서 사용
- 인자라고도 함

# Map과 Set 그리고 Lookup Table

- 데이터를 저장하고 효율적으로 검색하는데 사용되는 데이터 구조

### Map

- 키-값 쌍을 저장하는 컬렉션
- 객체와 비슷하지만 객체는 문자열만 키로 사용할 수 있지만 `Map`은 모든 자료형을 키로 사용할 수 있음
- 삽입 순서가 유지된다.
- 전용 메서드인 `set`, `get`, `has`, `delete`, `clear` 등을 사용하여 데이터 조작 가능

### Set

- 중복되지 않은 값들의 집합
- 값이 중복되지 않고 삽입된 순서대로 순차적으로 접근할 수 있음
- 내부적으로는 순서에 의존하지 않지만, `forEach`, `for...of`를 사용해서 순차적으로 접근 가능

### Lookup Table

- 데이터를 효율적으로 조회할 수 있도록 미리 준비된 데이터 집합을 의미
- `Map`이나 객체를 활용하여 구현할 수 있음
- 객체나 `Map`에서는 키가 중복될 수 없고 동일한 키에 새로운 값을 할당하면 이전 값이 덮어씌워진다.

# 프로토타입 🔥

## 객체지향 프로그래밍은 무엇을 의미하나요? 🔥

- 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.

## 객체지향 프로그래밍의 특징에 대해 말해볼 수 있나요? 🔥

- 추상화
  - 복잡한 시스템에서 꼭 필요한 속성과 동작만을 모델링하여 표현하는 것
  - 불필요한 세부 사항을 숨기고 중요한 것만 강조
- 캡슐화
  - 객체의 속성과 메서드를 하나로 묶어서 외부에서 객체의 내부 상태에 직접 접근할 수 없도록 제한하는 것
  - 정보를 은닉하고 객체 간의 독립성을 유지
- 상속
  - 부모 객체의 속성이나 기능을 자식 객체가 물려받는 것
  - 코드 중복을 줄이고 재사용할 수 있고 새로운 객체가 기존 객체의 특성을 확장할 수 있음
- 다형성
  - 같은 이름의 메서드가 다른 방식으로 동작하는 것
  - 부모 클래스에서 정의된 메서드를 자식 클래스에서 오버라이딩하여 각 객체에 맞게 다르게 동작하도록 할 수 있다.

## 자바스크립트는 객체지향 프로그래밍 언어인가요?

- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.
- 클래스 기반 객체지향 언어(C++, JAVA)와는 다르게 자바스크립트는 프로토타입 기반 객체지향 언어이다.

### 프로토타입 기반 객체지향 언어란?

- 클래스가 아닌 프로토타입을 사용하여 객체 간의 상속을 구현하는 언어
- 자바스크립트는 프로토타입을 통해 객체 간의 상속을 구현하며 클래스 기반 언어와 달리 `[[Prototype]]` 속성으로 상속 관계를 형성
- 모든 객체는 숨겨진 `[[Prototype]]` 속성을 통해 부모 객체를 참조하고 이를 통해 속성과 메서드를 상속받는다.

## 프로토타입이 뭔가요?

- 프로토타입은 객체 간에 상속을 구현하기 위한 템플릿 객체이다.
- 객체는 프로토타입을 통해 다른 객체의 속성과 메서드를 공유하거나 상속받는다.
- `prototype`과 `[[Prototype]]`은 객체 지향 프로그래밍에서 상속과 다형성을 구현하는 중요한 역할을 한다.

1. `prototype`: 생성자 함수의 속성으로 생성된 객체가 참조하는 부모 객체
2. `[[Prototype]]`: 모든 객체의 숨겨진 속성으로 상속 관계에서 부모 객체를 가리킨다.

```
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function() {
  return `Hello, I'm ${this.name}`;
};

const p1 = new Person('Alice');
console.log(p1.sayHello()); // Hello, I'm Alice
```

### `Prototype` vs `[[Prototype]]` 요약

| **특징**                | **`prototype`**                                         | **`[[Prototype]]`**                               |
| ----------------------- | ------------------------------------------------------- | ------------------------------------------------- |
| **역할**                | 생성자 함수가 생성한 객체들이 상속받는 부모 객체를 정의 | 객체가 상속받는 부모 객체를 참조                  |
| **누가 가지고 있나요?** | 생성자 함수만 가짐                                      | 모든 객체가 가짐 (내부적으로 숨겨져 있음)         |
| **어떻게 설정되나요?**  | 생성자 함수에서 개발자가 정의                           | 모든 객체에 자동으로 설정                         |
| **어떻게 접근하나요?**  | `ConstructorFunction.prototype`                         | `Object.getPrototypeOf(obj)` 또는 `obj.__proto__` |

# strict mode 🔥

## strict mode가 뭔가요?

- 자바스크립트 실행을 더 엄격하게 제한하는 기능
- ES5에서 도입되었고 런타임시 코드의 잠재적인 오류를 더 빨리 찾아내고 안전하게 작성하도록 도와줌
- 코드 최상단에 `"use strict";` 선언하거나 모듈 스크립트를 사용하면 활성화

## strict mode를 통해 무엇을 예방할 수 있죠?

- 암묵적 전역 변수 방지

  - 변수를 선언하지 않고 값을 할당하면 ReferenceError 발생

  ```
  "use strict";
  x = 10; // ReferenceError: x is not defined
  ```

- 변수, 함수, 매개변수의 삭제 금지

  ```
  "use strict";
  let foo = 10;
  delete foo; // SyntaxError: Delete of an unqualified identifier is not allowed
  ```

- 매개변수 이름 중복 금지

  ```
  "use strict";
  function add(a, a) { // SyntaxError: Duplicate parameter name not allowed in this context
    return a + a;
  }
  ```

- `with`문 사용 금지

  - `with`문은 스코프를 혼란스럽게하여 유지보수가 어려워짐

  ```
  "use strict";
  with (Math) { // SyntaxError: Strict mode code may not include a with statement
    console.log(PI);
  }
  ```

- `this` 값의 암시적 변환 방지

  - 함수에서는 `this`가 암시적으로 `window`를 가리키지 않고 `undefined`로 설정

  ```
  "use strict";
  function myFunction() {
    console.log(this); // undefined (기존에는 글로벌 객체 `window`)
  }
  myFunction();
  ```

- 읽기 전용 속성 수정 방지

  - 객체 속성이 읽기 전용인 경우 수정하면 오류 발생

  ```
  "use strict";
  const obj = Object.freeze({ x: 10 });
  obj.x = 20; // TypeError: Cannot assign to read only property 'x'
  ```

# 빌트인 객체 🔥

## 빌트인 객체가 뭔가요? 종류는 어떤게 있죠?

- 자바스크립트에서 기본적으로 제공하는 객체
- ECMAScript 사양에 정의된 객체
- 애플리케이션 전역의 공통 기능 제공
- 자바스크립트 실행 환경과 관계없이 언제나 사용할 수 있음
- 전역 객체의 프로퍼티로서 제공
- Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, Function, Promise, Reflect, Proxy, JSON, Error

### 자바스크립트 객체의 분류

- 표준 빌트인 객체
- 호스트 객체
  - 자바스크립트 실행환경에 따라 추가적으로 제공되는 객체
- 사용자 정의 객체
  - 사용자가 직접 정의한 객체를 의미

## 래퍼 객체에 대해서 알고 있나요?

- 문자열, 숫자, 불리언 원시 값에 대해 **객체처럼 접근하면 생성되는 임시 객체**
- 래퍼 객체는 원시 값에 대해 메서드를 사용할 수 있게 함

```
const str = "Hello"; // 문자열 원시 값

// 문자열 원시 값에 프로퍼티 추가 시도
str.name = "Lee"; // 임시 래퍼 객체가 생성되며 프로퍼티를 추가하려 시도함

// 추가한 프로퍼티 확인
console.log(str.name); // undefined (임시 객체는 삭제되었기 때문에 접근 불가)

// 원시 값의 타입과 값 확인
console.log(typeof str, str);
// string Hello (원시 값은 변하지 않고 그대로 유지됨)
```

- 생성된 래퍼 객체는 일시적으로만 존재
- 이후 자동으로 삭제되어 메모리 관리에 영향을 주지 않음

# this 🔥

## this가 뭔가요? 🔥

- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수

## this 바인딩이란? 🔥

**식별자와 값을 연결하는 과정**

- ex. 변수 선언 시 변수 이름(식별자)과 메모리 주소를 연결
- `this 바인딩`은 **`this`와 그것이 가리킬 객체를 연결하는 과정**.
- `this`는 **동적으로 바인딩**되며 함수 호출 방식에 따라 달라짐

## this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?

**호출 시점과 방식**에 따라 `this`에 바인딩되는 객체가 달라짐

#### 1. 일반 함수 호출 (콜백 함수, 내부 함수 포함)

- `this`는 **전역 객체**를 가리킴 (브라우저: `window`, Node.js: `global`)
- 엄격 모드에서는 `undefined`가 바인딩

#### 2. 메서드 호출

- 호출된 메서드의 주체 객체가 `this`로 바인딩됨

#### 3. 생성자 함수 호출

- `this`는 **새로 생성된 객체**를 가리킴

#### 4. 화살표 함수 호출

- 화살표 함수의 `this`는 상위 스코프의 `this`를 계승

#### 5. Function.prototype.apply/call/bind 메서드에 의한 간접 호출

- `call`
  - 즉시 실행되며 첫 번째 인수로 전달된 객체가 **this**로 바인딩
- `apply`
  - `call`과 같지만 인자를 배열로 전달.
  - 첫 번째 인수로 전달된 객체가 **this**로 바인딩
- `bind`

  - 새로운 함수를 반환하며, 첫 번째 인수로 전달된 객체가 **this**로 고정
  - 반환된 함수는 나중에 실행되며, **this**가 고정된 상태로 실행됨

  #### 인수와 인자의 차이

  - 인수: 함수를 호출할 때 함수에 전달되는 값
  - 인자: 함수 정의 시 함수가 받을 값의 이름

# 실행 컨텍스트 🔥

## 실행 컨텍스트에 대해 말해보세요 🔥🔥

실행 컨텍스트는 자바스크립트 코드가 실행되는 환경이다.

자바스크립트 엔진은 코드를 실행하기 위해 실행 컨텍스트를 생성하고 관리하며 함수가 호출될 때마다 새로운 실행 컨텍스트가 생성되고 콜 스택에 쌓인다.

### 실행 컨텍스트의 구성 요소

실행 컨텍스트는 실행 컨텍스트 스택과 렉시컬 환경으로 구성된다.

**실행 컨텍스트 스택**

- 자바스크립트 코드가 실행될 때, 각 함수 호출은 실행 컨텍스트를 생성하고 콜 스택에 쌓인다.
- 가장 먼저 **전역 실행 컨텍스트**가 생성되고, 이후 함수가 호출되면 함수마다 새로운 실행 컨텍스트가 스택에 쌓인다.
- 함수 실행이 종료되면 해당 컨텍스트는 스택에서 제거된다.
- LIFO(후입선출) 방식으로 작동한다.

**렉시컬 환경**

- 실행 컨텍스트 내에서 변수와 함수의 선언, 그리고 **상위 스코프 정보**를 관리
- 렉시컬 환경은 환경 레코드와 외부 렉시컬 환경 참조로 구성된다.

  **환경 레코드**

  - 현재 실행 중인 코드의 변수와 함수 선언 정보를 저장
  - let, const, var와 같은 변수와 함수 선언이 여기에 기록

  **외부 렉시컬 환경 참조**

  - 현재 렉시컬 환경의 상위 스코프를 참조하여 스코프 체인을 형성
  - 이를 통해 함수 내에서 선언되지 않은 변수를 상위 스코프에서 검색할 수 있다.
  - 함수가 호출될 때, 호출 당시의 상위 스코프 정보를 기반으로 새로운 렉시컬 환경이 생성된다.

**this 바인딩**

- 실행 중인 코드에서 this가 참조하는 객체를 저장.
- 전역 컨텍스트에서는 전역 객체(window 또는 global), 함수에서는 호출 방식에 따라 동적으로 this가 결정된다.

### 실행 컨텍스트의 동작 원리

실행 컨텍스트는 스택구조로 관리

1. **전역 실행 컨텍스트 생성**  
   코드 실행이 시작되면 가장 먼저 전역 실행 컨텍스트가 생성되고 스택에 추가
2. **함수 호출 시 실행 컨텍스트 생성**
   함수를 호출할 때마다 해당 함수의 실행 컨텍스트가 생성되어 콜 스택 최상단에 쌓임임
3. **함수 종료 시 실행 컨텍스트 제거**  
   함수 실행이 끝나면 해당 실행 컨텍스트는 콜 스택에서 제거

```
function outer() {
  let outerVar = "Outer";

  function inner() {
    let innerVar = "Inner";
    console.log(outerVar); // "Outer"
    console.log(innerVar); // "Inner"
  }

  inner();
}

outer();
```

1. 전역 컨텍스트 생성 → outer 함수 호출
2. outer 컨텍스트 생성 → inner 함수 호출
3. inner 컨텍스트 생성 → 실행 후 스택에서 제거
4. outer 컨텍스트 실행 종료 → 스택에서 제거

즉, 실행 컨텍스트는 자바스크립트 코드가 실행되는 환경으로, 스택 구조를 통해 함수 호출과 실행 순서를 관리하며 변수, 스코프, this를 포함한다.
