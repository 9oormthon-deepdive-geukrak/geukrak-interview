# 프로그래밍 🔥

## 프로그래밍이란 뭐라고 생각하나요?

- 프로그래밍은 컴퓨터가 주어진 작업을 수행할 수 있도록 명령을 작성하는 과정이다.

## 컴파일러는 뭐고 인터프리터는 뭔가요?

### 컴파일러(Compiler)

- 프로그래밍 언어로 작성된 소스 코드를 기계어로 번역하는 프로그램

  ### 장점

  - 컴파일된 프로그램은 실행 시 번역이 필요없어 실행 속도가 빠르다.
  - 컴파일 단계에서 문법 오류를 모두 확인하고 실행 전에 오류를 고칠 수 있다.

  ### 단점

  - 소스 코드가 크면 컴파일 하는데 오래 걸린다.
  - 컴파일된 실행 파일은 특정 운영체제나 환경에 종속되어 다른 환경에서 재컴파일이 필요할 수 있다.
  - 디버깅이 어렵다.

### 인터프리터(Interpreter)

- 프로그래밍 언어로 작성된 코드를 **한 줄씩** 읽고 해석하여 즉시 실행하는 프로그램이다.

  ### 장점

  - 코드를 수정하고 바로 실행할 수 있어 코드 작성과 테스트가 빠르다.
  - 한 줄씩 실행하기 때문에 디버깅이 편리하다.
  - 특정 플랫폼에 종속되지 않아 여러 운영체제에서 동일하게 실행할 수 있다.

  ### 단점

  - 한 줄씩 번역하기 때문에 컴파일된 프로그램보다 실행 속도가 느리다.
  - 실행 전에 모든 오류를 확인할 수 없다.

# 자바스크립트란 🔥

- 자바스크립트는 동적인 웹페이지를 만들기 위한 프로그래밍 언어

## 자바스크립트의 특징은 뭐가 있나요?

### 가벼운 언어

- 자바스크립트는 경량 언어로 초기 로딩과 실행이 빠르다.

### 인터프리터 언어

- 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**

- **코드를 한 줄씩 해석하여 실행**

  대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합하여 처리 속도 최적화한다.

  - 인터프리터는 소스코드를 즉시 실행
  - JIT(Just-In-Time)컴파일러는 머신 코드를 생성하고 최적화

- 이런 방식 덕분에 실행 속도가 빨라서 빠른 피드백과 디버깅이 가능하다

  #### 모던 자바스크립트 엔진이란?

  - 최신 웹 브라우저와 js실행 환경에서 사용되는 고성능 자바스크립트 처리 엔진
  - 자바스크립트 코드를 효율적으로 해석, 컴파일, 실행하기 위해 설계되었고 빠른 실행 속도와 최적화를 지원
  - JIT 컴파일
    - 코드 실행 전 바이트코드로 컴파일하여 실행 속도 높임
    - 자주 실행되는 코드를 최적화하여 성능을 더 높이는 기술 사용
  - 가비지 컬렉션
    - 사용되지 않는 메모리를 자동으로 정리하여 효율적으로 메모리 관리
  - 멀티스레딩 지원
    - 백그라운드 작업을 위한 멀티스레딩 기술 사용하여 성능 향상
  - `V8(Google)`, `SpiderMonkey(Mozilla)`, `JavaScriptCore(WebKit)`, `Chakra(Microsoft)`

### 동적 타입 언어

- 변수의 데이터 타입이 고정되지 않고 실행 중 변경될 수 있다.

  ```
  let value = 5;
  value = "hello";
  ```

### 객체 기반 언어

- 모든 데이터가 객체로 표현될 수 있다.

### 프로토타입 기반 상속

- 자바스크립트는 클래스 기반 언어가 아닌 **프로토타입 기반 언어**이다.

### 멀티 패러다임 언어

- 객체 지향(OOP), 함수형(FP), 절차적 프로그래밍 모두 지원한다.

### 이벤트 기반 비동기 처리 지원

- callback, Promise, async/await 제공
- 이벤트 루프를 통해 효율적으로 비동기 작업 처리

### 브라우저와 플랫폼 독립적으로 동작

- 브라우저와 서버 모두에서 실행 가능

# 변수 🔥

## 변수란 무엇인가요?

- 데이터를 저장하기 위한 이름이 붙은 메모리 공간
- 즉, 값의 위치를 가리키는 상징적인 이름
- 변수는 언제든지 값이 바뀔 수 있다.
- 자바스크립트에서 변수는 선언 시 `호이스팅`이라는 메커니즘에 의해 코드의 상단으로 끌어올려진다.
  - **호이스팅(Hoisting)**: 변수 선언이 런타임 이전에 스코프의 최상단으로 끌어올려지는 자바스크립트의 동작 방식
  - `var`로 선언한 변수는 초기화 전에 접근 가능하며, 값은 `undefined`로 설정된다.
    - 이는 선언이 호이스팅되지만, 초기화가 실제 실행 시점에 이루어지기 때문
  - `let`과 `const`는 호이스팅되더라도 **초기화 이전에는 접근할 수 없다**. (일시적 사각지대, TDZ)

## 식별자란 무엇인가요? 🔥

- 식별자는 변수, 함수, 객체 등을 구별하기 위해 사용하는 이름
- 식별자는 값이 아니라 메모리 주소를 기억한다.

## 변수를 선언한다는 것은 어떤 것을 의미하나요?

- 데이터를 저장하기 위해 메모리 공간을 확보하고 확보된 메모리 공간의 주소와 변수 이름을 연결해서 값을 저장할 수 있게 하는 것을 의미한다.

  ```
  let a = 5;
  // a라는 이름으로 메모리 공간을 확보하고 해당 공간에 값 5를 저장
  ```

- `var`, `let`, `const`를 사용하여 변수를 선언한다.

## var 키워드는 뭔가요?

- `var` 키워드는 변수를 선언할 때 사용하는 것이다.
- ES6 이전까지는 변수를 선언하는 유일한 방법
- 과거에 브라우저 호환성 때문에 주로 사용되었다.
  - 현재는 `let`과 `const`가 도입되어 사용을 권장하지 않음

### var 특징

- 함수 스코프
  - var로 선언된 변수는 함수 내부 전체에서 유효
  - 블록 스코프를 지원하지 않아 블록`{}` 안에서 선언해도 블록 외부에서 접근 가능
- 변수 호이스팅
  - var로 선언된 변수는 함수 또는 스크립트의 최상단으로 끌어올려진 것처럼 동작
  - 하지만 초기화는 끌어올려지지 않는다.
- 중복 선언 가능

  - 동일한 이름으로 여러 번 변수를 선언해도 에러 발생 x

  ### 변수 선언 비교

  |                | `var`                                  | `let`                               | `const`                             |
  | -------------- | -------------------------------------- | ----------------------------------- | ----------------------------------- |
  | 스코프         | 함수 스코프                            | 블록 스코프                         | 블록 스코프                         |
  | 재선언         | 재선언 가능                            | 재선언 불가능                       | 재선언 불가능                       |
  | 초기화 전 접근 | 선언 전에 접근 가능 (`undefined` 반환) | 선언 전에 접근 불가(참조 에러 발생) | 선언 전에 접근 불가(참조 에러 발생) |
  | 값 변경        | 초기값 변경 가능                       | 초기값 변경 가능                    | 초기값 변경 불가(상수)              |

## 호이스팅이 뭔가요? 🔥🔥

- 호이스팅은 자바스크립트 엔진이 코드를 실행하기 전에 **변수나 함수 선언을 최상단으로 끌어올리는 동작**을 말한다.
- **변수 선언만 끌어올려지고 초기화는 원래 위치에서 수행**된다.
- 메모리 할당 측면에서, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하고, 값 할당은 실행 시점에 이루어진다.

예제1

```
console.log(score); // undefined
var score; // 변수 선언문
```

- 아직 score가 선언이 되지 않았을 때 score를 출력하면 인터프리터에 의해 참조 에러가 발생할 것처럼 보인다.
- 호이스팅 때문에 `undefined` 출력
- `undefined`가 출력되는 이유는 변수 선언이 코드가 한 줄씩 실행되는 시점(런타임 시점)이 아닌, 그 이전 단계에서 먼저 실행되기 때문이다.

예제2

```
console.log(x); // undefined (변수 선언은 끌어올려졌지만 초기화되지 않음)
var x = 5;
console.log(x); // 5
```

이 코드의 실제 실행 순서

```
var x;         // 선언이 호이스팅됨
console.log(x); // undefined
x = 5;         // 초기화는 원래 위치에서 수행됨
console.log(x); // 5
```

### `let`, `const`도 호이스팅이 발생하는가?

- `var`, `let`, `const` 모두 호이스팅 발생하지만 동작이 다르다.
- `var`는 선언과 동시에 초기화가 일어나서 참조 에러가 발생하지 않음
- `let`과 `const`는 선언이 된 후에 초기화가 일어나므로, 초기화 전에 참조하면 참조 에러 발생
  - 이를 **일시적 사각지대(TDZ)**라고 함

### 호이스팅 범위

- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용하는 모든 식별자는 호이스팅 된다.

## var 키워드의 문제점은 무엇이 있나요? 🔥

### 1. 변수 중복 선언 허용

- 동일한 변수명을 여러 번 선언해도 에러가 발생하지 않고 이전 값을 덮어씀
- 복잡한 코드에서 변수 관리 어려워질 수 있음
  ```
  var c = 5;
  var c = 10; // 에러 없이 덮어씀
  console.log(c); // 10
  ```

### 2. 함수 레벨 스코프(블록 레벨 스코프 미지원)

- `var`는 함수 스코프를 가진다.
- `{}` 블록 안에서 선언된 변수도 블록 외부에서 접근 가능하여 예기치 않은 동작이 발생할 수 있다.

  ```
  var a = 1; // a는 전역변수

  if (true) {
    var a = 10;
  }
  console.log(a); // 10 (블록 외부에서도 접근 가능)
  ```

### 3. 변수 호이스팅으로 인한 예측 불가능

- `var` 키워드로 선언된 변수는 호이스팅되어 선언 전에 접근이 가능하다.
- 위 호이스팅 설명에 있는 예제 참고

## let 키워드는 var 키워드와 어떤 점이 다른가요? 🔥🔥

### `let`

- 변수 중복 선언 x
- 재할당 가능
- 블록 레벨 스코프
- `let`은 호이스팅이 발생하지만, 선언 이전에 참조하면 참조 에러 발생

  - `var`는 선언문 이전에 참조하면 `undefined` 반환
  - `var`는 런타임 이전에 선언과 동시에 초기화되지만, `let`은 초기화 단계까지 변수를 참조할 수 없다.
  - 선언 단계부터 초기화 단계시작 전까지 해당 변수를 참조할 수 없으며, 이 구간을 `일시적 사각지대(TDZ)`라고 한다.

    <div style="display: flex; justify-content: space-around; align-items: center;">
      <img src="./images/let_const.png" alt="let/const_호이스팅" title="let/const" style="width: 45%; height: auto;">
      <img src="./images/var.png" alt="var_호이스팅" title="var" style="width: 45%; height: auto;">
    </div>

## const 키워드는 어떤 특징이 있나요? 🔥

### `const`

- 반드시 선언과 동시에 초기화해야 함
- 재선언, 재할당 금지 (단, 객체나 배열의 내용은 변경 가능)
- 블록 레벨 스코프
- `let`과 마찬가지로 호이스팅이 발생하지만, 선언 이전에 참조하면 참조 에러 발생

### 왜 const로 선언한 객체와 배열은 내용 변경이 가능한가?

- const는 변수 자체를 불변으로 만드는 것이 아니라 변수의 참조 주소 변경을 막는 것이기 때문이다.
- 객체나 배열은 **참조형 데이터**로, 변수에는 값 자체가 아니라 메모리 주소가 저장된다.
- 따라서 const로 선언된 변수는 주소 변경은 불가능하지만, 주소가 가리키는 객체나 배열의 내용 수정은 가능하다.

## TDZ 🔥🔥

- 일시적 사각지대
- 변수 선언은 되었지만 초기화가 단계가 시작되기 전까지의 구간을 의미
- TDZ 동안 변수를 사용할 수 없고 초기화 시점부터 참조 가능
- 선언 → TDZ → 초기화 → 할당

### 변수 선언, 초기화, 할당의 차이점

- **변수 선언**: 변수를 생성하는 것을 의미

  - 해당 식별자를 스코프에 등록하여 나중에 참조할 수 있도록 함

- **초기화**: 메모리에 변수 저장을 위한 공간을 확보하는 단계
- 이때 변수는 기본값으로 `undefined`가 할당

- **할당**: 변수에 실제 값을 할당하는 단계
  - `=` 연산자를 사용하여 값을 할당
  - 초기값이 `undefined`인 경우 실제 값을 할당해주는 단계

## 식별자 네이밍 규칙은 어떤 것들이 있나요?

- 특수문자를 제외한 **문자, 숫자, 언더스코어(`_`), `$`**만 사용가능하다.
- 숫자로 시작할 수 없다.
- 대소문자 구분이 가능하다.
- 예약어는 사용할 수 없다. (`await`, `break`, `class`, `for`, `if`, `this` 등)
  - 예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어

## 네이밍 컨벤션은 어떤 것들이 있나요?

네이밍 컨벤션은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 규칙

```
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

- 헝가리언 케이스는 타입을 변수명 앞에 붙여 타입을 명시하는 방식

## 리터럴이 뭔가요?

- 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.
- 즉, 값을 직접 표현한 것이다.
- 숫자, 문자열, 배열, 객체, 불리언, null 등
- 리터럴은 값 자체를 표현한 것으로 변수나 상수에 할당할 수 있는 값이다.

### 상수와 리터럴 차이

- 상수는 값을 변경할 수 없는 메모리 공간을 나타내며, 선언 후 메모리 값을 변경할 수 없다.
- 리터럴은 특정 값을 직접 표현한 것으로 변수나 상수에 할당될 수 있고, 메모리 안에 저장된다.

# 데이터 타입 🔥

- 데이터 타입은 값의 종류를 의미
- 원시 타입과 객체 타입으로 분류할 수 있다.
- **저장 가능한 메모리 크기**

## 원시 타입과 객체 타입의 차이점

| **항목**        | **원시 타입**                       | **객체 타입**                      |
| --------------- | ----------------------------------- | ---------------------------------- |
| **특성**        | 값 자체를 저장                      | 참조를 저장                        |
| **저장 위치**   | 스택                                | 힙                                 |
| **복사 방식**   | 값 자체가 복사                      | 참조(주소)가 복사                  |
| **변경 가능성** | 불변성                              | 가변성                             |
| **용도**        | 숫자, 문자열, 논리값 등 단순 데이터 | 복잡한 데이터 구조 (객체, 배열 등) |

### 💡핵심 차이

- 원시 타입은 값을 변경할 수 없으며, 새 값이 저장되면 기존 값은 **새 메모리 공간에 저장**된다.
- 객체 타입은 동적으로 크기가 변하며, 변수는 객체의 **주소(참조 값)만 저장**한다.

## 데이터 타입의 종류는 어떤 것들이 있나요? 🔥

### 원시 타입

#### 1. 숫자 타입

- 정수와 소수를 포함한 숫자 표현
- 자바스크립트에서는 모든 수를 64비트 부동소수점 형식으로 처리 (정수 타입 없음)
- 2진수, 8진수, 16진수도 표현 가능하지만 모두 10진수로 해석된다.

#### 2. 문자열 타입

- 문자들의 집합. 변경 불가능한 값
- 큰따옴표, 작은따옴표, 백틱으로 감싸서 표현
- 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현 가능
- **왜 따옴표로 감싸는가?**
  - 따옴표를 사용하지 않으면 식별자로 인식할 수 있기 때문이다.

#### 3. 불리언 타입

- 논리적 참, 거짓

#### 4. undefined 타입

- 값이 할당되지 않은 변수를 나타냄
- var로 선언된 변수에 암묵적으로 undefined로 초기화
- 변수를 선언한 이후 값을 할당하지 않은 변수를 참조할 때도 undefined가 반환

#### 5. null 타입

- 값이 없음을 명시적으로 표현
- **객체가 존재하지 않음**을 나타낼 때 사용

#### 6. 심벌 타입

- ES6에서 추가된 7번째 타입
- 고유하고 변경 불가능한 값을 표현
- 다른 값과 중복되지 않는 유일무이한 값
- 주로 객체의 속성의 유일한 키로 사용
  - 같은 값으로 생성해도 서로 다른 고유 값을 가짐

#### 7. BigInt 타입

- 임의 정밀도로 정수를 나타낼 수 있는 숫자 원시 값 즉, 임의의 크기를 가진 정수를 표현
- 큰 정수도 안전하게 저장하고 연산할 수 있음
- 숫자 뒤에 n을 붙여 사용

### 객체 타입

- 객체
  - 키-값 쌍으로 이루어진 데이터 구조
- 배열
  - 순서가 있는 리스트 형태의 데이터 구조
- 함수
  - 재사용 가능한 코드 블록으로 객체의 한 종류

💡 **`undefined`는 값이 없음을 의미하고, `null`은 객체가 없음을 의미한다.**

## 심벌 타입은 뭐죠?

- ES6에서 도입된 고유하고 변경 불가능한 원시 데이터 타입
- 주로 객체 속성 키로 사용되며, 속성 충돌을 방지

### 특징

#### 1. 항상 유일한 값

- 심벌로 생성된 값은 동일한 설명이 있어도 절대 중복되지 않음

  ```
  const sym1 = Symbol('desc');
  const sym2 = Symbol('desc');
  console.log(sym1 === sym2); // false
  ```

#### 2. 객체 속성의 유일한 키로 사용 가능

- 객체의 유일한 속성 키로 사용 가능성
- 다른 키와 충돌하지 않음

#### 3. 자동 타입 변환 제한

- 암묵적 타입 변환 불가

  - 문자열이나 숫자로 변환되지 않음 → 고유한 심벌 값이 의도치 않게 훼손되는 것을 방지

  ```
  console.log('My symbol: ' + Symbol('desc')); // TypeError
  ```

- 명시적 변환 가능

  - 문자열로 변환하려면 `String()` 또는 `toString()` 메서드 사용

  ```
  const sym = Symbol('desc');
  console.log(String(sym)); // Symbol(desc)
  ```

#### 4. 심벌은 열거되지 않음

- `for...in`, `Object.keys()`, `getOwnPropertyNames()`로 접근할 수 없다.
- `Object.getOwnPropertySymbols()`로 확인 가능하다.

### 왜 사용하는가?

- 객체 속성 충돌 방지
  - 다른 사람이 만든 코드랑 겹칠 걱정 없음
- 기존 코드에 영향을 주지 않고 확장 가능
  - 외부 코드와 독립적인 속성을 추가할 때 유용
  - 안전하게 확장 가능

## 데이터 타입은 왜 필요할까요? 🔥

### 값을 저장할 때 필요한 메모리 공간의 크기를 결정하기 위해

- ex) 숫자형은 8바이트, 문자열은 문자 수에 따라 가변적인 크기를 가짐 → 이를 통해 메모리 사용을 최적화할 수 있음

### 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해

- ex) 숫자는 한 번에 8바이트를 읽고 처리, 문자열이나 객체는 그 크기에 맞춰 더 많은 메모리 공간을 읽어야 할 수 있음

### 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

- ex) `Number`는 숫자로 해석, `String`은 문자로 해석하는데 이는 값이 메모리에서 읽어질 때 어떤 방식으로 처리될지 정의

## 정적 타이핑이 뭔가요?

- 정적 타이핑은 변수의 타입이 **컴파일 시점**에 결정되는 방식
- 변수에 타입을 선언하고, 한 번 타입이 정해지면 다른 타입의 값을 할당할 수 없다.
- 정적 타이핑 언어에서는 변수의 타입을 선언하고 타입이 일치하지 않으면 컴파일 오류 발생
- ex) C, JAVA, TypeScript

```
int var = 10;
String str = 'Hello';
```

### 장점

- 오류를 미리 잡을 수 있어 코드 안정성과 예측 가능성이 높아짐
- 타입 정보가 명확하여 코드 가독성이 좋음
- 컴파일 시점에 타입이 확정되어 코드 최적화가 용이

### 단점

- 유연성이 떨어짐
- 타입을 변경해야 할 경우, 타입을 명시적으로 수정해야 함

## 동적 타이핑이 뭔가요?

- 동적 타이핑은 변수의 타입이 **실행 시점**에 결정되는 방식
- 변수 선언 시 타입을 명시하지 않으며, 값이 할당될 때 자바스크립트 엔진이 해당 값에 맞는 타입을 자동으로 할당함
- 변수의 타입은 할당된 값에 따라 동적으로 결정됨
- ex) JavaScript, Python

### 장점

- 코드 작성이 빠르고 유연하며, 변수의 타입을 명시하지 않아 코드가 간결함
- 타입 선언이 불필요하여 개발 속도가 빠르다.

### 단점

- 실행 시점에 타입 오류가 발생할 수 있어 런타임에서 버그가 발생할 가능성이 있다.
- 코드의 예측 가능성이 떨어지며, 잘못된 타입이 할당되면 의도치 않은 동작이 발생할 수 있다.
