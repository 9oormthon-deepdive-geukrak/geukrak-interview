# 프로그래밍 🔥

## 프로그래밍이란 뭐라고 생각하나요?

- 프로그래밍은 컴퓨터가 주어진 작업을 수행할 수 있도록 명령을 작성하는 과정이다.

## 컴파일러는 뭐고 인터프리터는 뭔가요?

### 컴파일러(Compiler)

- 프로그래밍 언어로 작성된 소스 코드를 기계어로 번역하는 프로그램

  ### 장점

  - 컴파일된 프로그램은 실행 시 번역이 필요없어 실행 속도가 빠르다.
  - 컴파일 단계에서 문법 오류를 모두 확인하고 실행 전에 오류를 고칠 수 있다.

  ### 단점

  - 소스 코드가 크면 컴파일 하는데 오래 걸린다.
  - 컴파일된 실행 파일은 특정 운영체제나 환경에 종속되어 다른 환경에서 재컴파일이 필요할 수 있다.
  - 디버깅이 어렵다.

### 인터프리터(Interpreter)

- 프로그래밍 언어로 작성된 코드를 **한 줄씩** 읽고 해석하여 즉시 실행하는 프로그램이다.

  ### 장점

  - 코드를 수정하고 바로 실행할 수 있어 코드 작성과 테스트가 빠르다.
  - 한 줄씩 실행하기 때문에 디버깅이 편리하다.
  - 특정 플랫폼에 종속되지 않아 여러 운영체제에서 동일하게 실행할 수 있다.

  ### 단점

  - 한 줄씩 번역하기 때문에 컴파일된 프로그램보다 실행 속도가 느리다.
  - 실행 전에 모든 오류를 확인할 수 없다.

# 자바스크립트란 🔥

- 자바스크립트는 동적인 웹페이지를 만들기 위한 프로그래밍 언어

## 자바스크립트의 특징은 뭐가 있나요?

### 가벼운 언어

- 자바스크립트는 경량 언어로 초기 로딩과 실행이 빠르다.

### 인터프리터 언어

- 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언어**

- **코드를 한 줄씩 해석하여 실행**

  대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합하여 처리 속도 최적화한다.

  - 인터프리터는 소스코드를 즉시 실행
  - JIT(Just-In-Time)컴파일러는 머신 코드를 생성하고 최적화

- 이런 방식 덕분에 실행 속도가 빨라서 빠른 피드백과 디버깅이 가능하다

  #### 모던 자바스크립트 엔진이란?

  - 최신 웹 브라우저와 js실행 환경에서 사용되는 고성능 자바스크립트 처리 엔진
  - 자바스크립트 코드를 효율적으로 해석, 컴파일, 실행하기 위해 설계되었고 빠른 실행 속도와 최적화를 지원
  - JIT 컴파일
    - 코드 실행 전 바이트코드로 컴파일하여 실행 속도 높임
    - 자주 실행되는 코드를 최적화하여 성능을 더 높이는 기술 사용
  - 가비지 컬렉션
    - 사용되지 않는 메모리를 자동으로 정리하여 효율적으로 메모리 관리
  - 멀티스레딩 지원
    - 백그라운드 작업을 위한 멀티스레딩 기술 사용하여 성능 향상
  - `V8(Google)`, `SpiderMonkey(Mozilla)`, `JavaScriptCore(WebKit)`, `Chakra(Microsoft)`

### 동적 타입 언어

- 변수의 데이터 타입이 고정되지 않고 실행 중 변경될 수 있다.

  ```
  let value = 5;
  value = "hello";
  ```

### 객체 기반 언어

- 모든 데이터가 객체로 표현될 수 있다.

### 프로토타입 기반 상속

- 자바스크립트는 클래스 기반 언어가 아닌 **프로토타입 기반 언어**이다.

### 멀티 패러다임 언어

- 객체 지향(OOP), 함수형(FP), 절차적 프로그래밍 모두 지원한다.

### 이벤트 기반 비동기 처리 지원

- callback, Promise, async/await 제공
- 이벤트 루프를 통해 효율적으로 비동기 작업 처리

### 브라우저와 플랫폼 독립적으로 동작

- 브라우저와 서버 모두에서 실행 가능

# 변수 🔥

## 변수란 무엇인가요?

- 데이터를 저장하기 위한 이름이 붙은 메모리 공간
- 즉, 값의 위치를 가리키는 상징적인 이름
- 변수는 언제든지 값이 바뀔 수 있다.
- 자바스크립트에서 변수는 선언 시 `호이스팅`이라는 메커니즘에 의해 코드의 상단으로 끌어올려진다.
  - **호이스팅(Hoisting)**: 변수 선언이 런타임 이전에 스코프의 최상단으로 끌어올려지는 자바스크립트의 동작 방식
  - `var`로 선언한 변수는 초기화 전에 접근 가능하며, 값은 `undefined`로 설정된다.
    - 이는 선언이 호이스팅되지만, 초기화가 실제 실행 시점에 이루어지기 때문
  - `let`과 `const`는 호이스팅되더라도 **초기화 이전에는 접근할 수 없다**. (일시적 사각지대, TDZ)

## 식별자란 무엇인가요? 🔥

- 식별자는 변수, 함수, 객체 등을 구별하기 위해 사용하는 이름
- 식별자는 값이 아니라 메모리 주소를 기억한다.
- 식별자 네이밍 규칙
  - 특수문자를 제외한 **문자, 숫자, 언더스코어(`_`), `$`**만 사용가능하다.
  - 숫자로 시작할 수 없다.
  - 대소문자 구분이 가능하다.
  - 예약어는 사용할 수 없다. (`let`, `if`, `return` 등)

## 변수를 선언한다는 것은 어떤 것을 의미하나요?

- 데이터를 저장하기 위해 메모리 공간을 확보하고 확보된 메모리 공간의 주소와 변수 이름을 연결해서 값을 저장할 수 있게 하는 것을 의미한다.

  ```
  let a = 5;
  // a라는 이름으로 메모리 공간을 확보하고 해당 공간에 값 5를 저장
  ```

- `var`, `let`, `const`를 사용하여 변수를 선언한다.

## var 키워드는 뭔가요?

- `var` 키워드는 변수를 선언할 때 사용하는 것이다.
- ES6 이전까지는 변수를 선언하는 유일한 방법
- 과거에 브라우저 호환성 때문에 주로 사용되었다.
  - 현재는 `let`과 `const`가 도입되어 사용을 권장하지 않음

### var 특징

- 함수 스코프
  - var로 선언된 변수는 함수 내부 전체에서 유효
  - 블록 스코프를 지원하지 않아 블록`{}` 안에서 선언해도 블록 외부에서 접근 가능
- 변수 호이스팅
  - var로 선언된 변수는 함수 또는 스크립트의 최상단으로 끌어올려진 것처럼 동작
  - 하지만 초기화는 끌어올려지지 않는다.
- 중복 선언 가능

  - 동일한 이름으로 여러 번 변수를 선언해도 에러 발생 x

  ### 변수 선언 비교

  |                | `var`                                  | `let`                               | `const`                             |
  | -------------- | -------------------------------------- | ----------------------------------- | ----------------------------------- |
  | 스코프         | 함수 스코프                            | 블록 스코프                         | 블록 스코프                         |
  | 재선언         | 재선언 가능                            | 재선언 불가능                       | 재선언 불가능                       |
  | 초기화 전 접근 | 선언 전에 접근 가능 (`undefined` 반환) | 선언 전에 접근 불가(참조 에러 발생) | 선언 전에 접근 불가(참조 에러 발생) |
  | 값 변경        | 초기값 변경 가능                       | 초기값 변경 가능                    | 초기값 변경 불가(상수)              |

## 호이스팅이 뭔가요? 🔥🔥

- 호이스팅은 자바스크립트 엔진이 코드를 실행하기 전에 **변수나 함수 선언을 최상단으로 끌어올리는 동작**을 말한다.
- **변수 선언만 끌어올려지고 초기화는 원래 위치에서 수행**된다.
- 메모리 할당 측면에서, 변수와 함수 선언은 미리 메모리 공간을 할당되고 값 할당은 실행 시점에 이루어진다.

예제1

```
console.log(score); // undefined
var score; // 변수 선언문
```

- 아직 score가 선언이 되지 않았을 때 score를 출력하면 인터프리터에 의해 참조 에러가 발생할 것처럼 보인다.
- 호이스팅 때문에 `undefined` 출력
- `undefined`가 출력되는 이유는 변수 선언이 코드가 한 줄씩 실행되는 시점(런타임 시점)이 아닌, 그 이전 단계에서 먼저 실행되기 때문이다.

예제2

```
console.log(x); // undefined (변수 선언은 끌어올려졌지만 초기화되지 않음)
var x = 5;
console.log(x); // 5
```

이 코드의 실제 실행 순서

```
var x;         // 선언이 호이스팅됨
console.log(x); // undefined
x = 5;         // 초기화는 원래 위치에서 수행됨
console.log(x); // 5
```

### `let`, `const`도 호이스팅이 발생하는가?

- `var`, `let`, `const` 모두 호이스팅 발생하지만 동작이 다르다.
- `var`는 선언과 동시에 초기화가 일어나서 참조 에러가 발생하지 않음
- `let`과 `const`는 선언이 된 후에 초기화가 일어나므로, 초기화 전에 참조하면 참조 에러 발생
  - 이를 **일시적 사각지대(TDZ)**라고 함

### 호이스팅 범위

- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용하는 모든 식별자는 호이스팅 된다.

## var 키워드의 문제점은 무엇이 있나요? 🔥

### 1. 변수 중복 선언 허용

- 동일한 변수명을 여러 번 선언해도 에러가 발생하지 않고 이전 값을 덮어씀
- 복잡한 코드에서 변수 관리 어려워질 수 있음
  ```
  var c = 5;
  var c = 10; // 에러 없이 덮어씀
  console.log(c); // 10
  ```

### 2. 함수 레벨 스코프(블록 레벨 스코프 미지원)

- `var`는 함수 스코프를 가진다.
- `{}` 블록 안에서 선언된 변수도 블록 외부에서 접근 가능하여 예기치 않은 동작이 발생할 수 있다.

  ```
  var a = 1; // a는 전역변수

  if (true) {
    var a = 10;
  }
  console.log(a); // 10 (블록 외부에서도 접근 가능)
  ```

### 3. 변수 호이스팅으로 인한 예측 불가능

- `var` 키워드로 선언된 변수는 호이스팅되어 선언 전에 접근이 가능하다.
- 위 호이스팅 설명에 있는 예제 참고

## let 키워드는 var 키워드와 어떤 점이 다른가요? 🔥🔥

### `let`

- 변수 중복 선언 x
- 재할당 가능
- 블록 레벨 스코프
- `let`은 호이스팅이 발생하지만, 선언 이전에 참조하면 참조 에러 발생

  - `var`는 선언문 이전에 참조하면 `undefined` 반환
  - `var`는 런타임 이전에 선언과 동시에 초기화되지만, `let`은 초기화 단계까지 변수를 참조할 수 없다.
  - 선언 단계부터 초기화 단계시작 전까지 해당 변수를 참조할 수 없으며, 이 구간을 `일시적 사각지대(TDZ)`라고 한다.

  ![let/const_호이스팅](./images/let_const.png "let/const")
  ![var_호이스팅](./images/var.png "var")

## const 키워드는 어떤 특징이 있나요? 🔥

### `const`

- 반드시 선언과 동시에 초기화해야 함
- 재선언, 재할당 금지 (단, 객체나 배열의 내용은 변경 가능)
- 블록 레벨 스코프
- `let`과 마찬가지로 호이스팅이 발생하지만, 선언 이전에 참조하면 참조 에러 발생

### 왜 const로 선언한 객체와 배열은 내용 변경이 가능한가?

- const는 변수 자체를 불변으로 만드는 것이 아니라 변수의 참조 주소 변경을 막는 것이기 때문이다.
- 객체나 배열은 **참조형 데이터**로, 변수에는 값 자체가 아니라 메모리 주소가 저장된다.
- 따라서 const로 선언된 변수는 주소 변경은 불가능하지만, 주소가 가리키는 객체나 배열의 내용 수정은 가능하다.

## TDZ 🔥🔥
- 일시적 사각지대
- 변수 선언은 되었지만 초기화가 단계가 시작되기 전까지의 구간을 의미
- TDZ 동안 변수를 사용할 수 없고 초기화 시점부터 참조 가능
- 선언 → TDZ → 초기화 → 할당