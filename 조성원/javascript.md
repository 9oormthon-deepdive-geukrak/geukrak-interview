## 프로그래밍

### 프로그래밍이란 뭐라고 생각하나요?

- 컴퓨터가 작업을 수행하기 위해 따를 수 있는 프로그램이라는 명령어 순차 조합을 구성하는 것

&nbsp;

### 컴파일러는 뭐고 인터프리터는 뭔가요?

- 컴파일러
  - 프로그램 전체를 스캔해 모두 기계어로 번역
  - 초기 스캔 시간이 오래 걸리지만, 실행 시간은 빠르다.
  - 많은 메모리 사용
    - 고급언어로 작성된 소스를 기계어로 번역(오브젝트 코드)
    - 만들어진 오브젝트 코드를 묶어서 하나의 실행 파일로 제작(링킹)
  - 코드 전체를 검사한 후 오류 메시지를 생성하므로 실행 전에 오류를 발견할 수 있다.
- 인터프리터
  - 프로그램 실행 시 한 번에 한 문장씩 번역
  - 메모리 효율이 좋으나, 실행 시간이 오래 걸린다.
  - 오류를 만나면 프로그램을 중지한다.

&nbsp;

## 자바스크립트란

### 자바스크립트의 특징은 뭐가 있나요?

- 웹 브라우저에서 동작하는 프로그래밍 언어
  - HTML, CSS와 함께 웹을 구성
- 인터프리터 언어
  - 개발자가 별도의 컴파일 작업을 수행하지 않는다.
  - 크롬의 V8 등의 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결
- 멀티 패러다임 프로그래밍 언어
  - 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원
- 프로토타입 기반의 객체지향 언어

&nbsp;

## 변수

### 변수란 무엇인가요?

- 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념
- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 값의 위치를 가리키는 상징적인 이름
  - 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행
- 사람이 이해할 수 잇는 언어로 명명한 변수 이름을 통해 변수에 저장된 값의 의미를 명확히 할 수 있다.

&nbsp;

### 식별자란 무엇인가요?

- 변수 이름
- 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 값은 메모리 공간에 저장돼 있고, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해 낼 수 있어야 한다.
  - 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야 한다.
  - 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.
  - 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
- 변수 이름에만 국한해서 사용하지 않으며, 변수, 함수, 클래스 등의 이름은 모두 식별자이다.
- 네이밍 규칙을 준수해야 한다.

&nbsp;

### 변수를 선언한다는 것은 어떤 것을 의미하나요?

- 변수를 생성하는 것을 의미
- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것
- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용 가능
- 변수 선언의 두 단계
  1. 선언: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
  2. 초기화 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화
- 변수 이름은 실행 컨텍스트에 등록된다.
  - 실행 컨텍스트: 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
  - 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리

&nbsp;

### `var` 키워드는 뭔가요?

- ES6 이전, 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드
- 자바스크립트 엔진에 의해 암묵적으로 `undefined` 값이 할당되어 초기화된다.

&nbsp;

### 호이스팅이 뭔가요?

- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 변수 선언(선언과 초기화)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행
- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.
- 값의 할당은 런타임에 실행된다.

&nbsp;

### `var` 키워드의 문제점은 무엇이 있나요?

- 함수 스코프
  - `var` 키워드로 정의된 변수는 함수 스코프이기 때문에, 함수를 벗어난 영역에서 사용하면 에러가 발생한다.
  - 함수 안에서 `var` 키워드를 사용하지 않고 변수에 값을 할당하면 그 변수는 전역변수가 된다.
    - 전역 변수가 되는 것을 피하기 위해서 파일의 최상단에 `use strict`를 사용한다. → 명시적으로 Reference Error가 발생한다.
  - `var`는 함수 스코프이기 때문에 `for`문, `if`문, `while`문 등에서 정의된 변수가 코드 실행이 완료된 후에도 계속 남아있게 되어 접근할 수 있다.
    - 즉시 실행 함수를 사용해 변수의 스코프를 제한할 수 있지만, 좋지 못한 코드가 된다.
  - 전역 공간인 `global`, `window` 등을 오염시키기도 한다.
- 호이스팅
  - JavaScript의 호이스팅은 직관적이지 않으며, 보통의 프로그래밍 언어에서는 찾아보기 힘든 기능이다.
  - 호이스팅된 `var` 변수는 `undefined`가 할당되며 실제 값은 원래 정의했던 위치에서 할당된다.
  - 변수가 정의된 곳 위에서 값을 할당할 수도 있다.
- 재정의
  - `var`를 이용하면 한 번 정의된 변수를 재정의할 수 있다.
- 재할당
  - 재할당 가능한 변수만 만들 수 있다. → 상수처럼 쓰여야하는 값도 재할당이 가능한 값으로 정의된다.

&nbsp;

### `let` 키워드는 `var` 키워드와 어떤 점이 다른가요?

- 블록 스코프
  - 많은 언어에서 블록 스코프를 사용한다.
  - 블록(`{}`) 바깥에서 사용하려고 하면 에러가 발생한다.
  - `const`와 `let`을 사용해서 동일한 이름의 변수를 정의하여 사용하는 경우, 우선순위에 따라 가장 가까운 변수를 사용하게 된다.
- 호이스팅
  - 변수를 정의하기 전에 그 변수를 사용하려고 하면 참조 에러가 발생한다.
  - 호이스팅 이후에 초기화하지 않는다. (TDZ)
- 재정의
  - `let`으로 정의된 변수는 재정의되지 않는다.

&nbsp;

### TDZ

- 일시적 사각지대
- 변수는 선언, 초기화, 할당의 3단계에 걸쳐 생성된다.
  - 선언: 변수를 실행 컨텍스트의 변수 객체에 등록하는 단계
  - 초기화: 실행 컨텍스트에 존재하는 변수 객체에 선언 단계의 변수를 위한 메모리를 만드는 단계
  - 할당: 사용자가 `undefined`로 초기화된 메모리의 값을 다른 값으로 할당하는 단계
- `var`로 선언된 변수는 선언과 초기화가 동시에 이루어진다.
- `let`, `const`로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.

  - 실행 컨텍스트에 변수를 등록했지만, 메모리가 할당되지 않아 접근이 불가능하다.
  - V8 엔진 코드

    ```c
    // var
    var->AllocateTo(VariableLocation::PARAMETER, index);

    // const
    VariableProxy* proxy =
        DeclareBoundVariable(local_name, VariableMode::kConst, pos);
    proxy->var()->set_initializer_position(position());

    // let
    VariableProxy* proxy =
        DeclareBoundVariable(variable_name, VariableMode::kLet, class_token_pos);
    proxy->var()->set_initializer_position(end_pos);
    ```

    - `var`와는 달리 `let`, `const`는 `set_initializer_position` 메소드를 통해 해당 코드의 위치를 의미하는 position 값만 정해준다.
    - 선언은 되어 있지만 변수에 값을 담기 위한 메모리에 공간이 확보되지 않은 상태

&nbsp;

### `const` 키워드는 어떤 특징이 있나요?

- `let`과 동일한 특징을 갖으나, 재할당되지 않는다.
  - **재할당**만 되지 않을 뿐, `const`로 정의된 객체의 내부 속성값은 수정이 가능하다.

&nbsp;

### 식별자 네이밍 규칙은 어떤 것들이 있나요?

- 특수문자를 제외한 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)를 포함할 수 있다.
- 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

&nbsp;

### 네이밍 컨벤션은 어떤 것들이 있나요?

- 일반적인 네이밍 컨벤션
  - 변수나 함수 이름에는 카멜 케이스 사용
    - camelCase
  - 생성자 함수, 클래스의 이름에는 파스칼 케이스 사용
    - PascalCase
- 다른 언어의 네이밍 컨벤션
  - DB에서 변수명, 함수명, 데이터 타입 등에 스네이크 케이스 사용
    - snake_case
  - url, HTML, CSS 등에서 케밥 케이스 사용
    - kebab-case
  - 상수를 표현할 때 사용하는 스크림 스네이크 케이스
    - SCREAM_SNAKE_CASE
  - 변수나 함수 이름 앞에 타입 접두사를 붙이는 헝가리안 표기법
    - strHungarian

&nbsp;

### 리터럴이 뭔가요?

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
- 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.
  - 값을 생성하기 위해 미리 약속한 표기법
- 리터럴의 종류
  - 정수 리터럴
  - 부동소수점 리터럴
  - 2진수 리터럴
  - 8진수 리터럴
  - 16진수 리터럴
  - 문자열 리터럴
  - 불리언 리터럴
  - `null` 리터럴
  - `undefined` 리터럴
  - 객체 리터럴
  - 배열 리터럴
  - 함수 리터럴
  - 정규 표현식 리터럴

&nbsp;

## 데이터 타입

### 데이터 타입의 종류는 어떤 것들이 있나요?

- 원시 타입
  - 숫자 타입
    - 모든 수를 실수로 처리하며, 64비트 부동소수점 형식을 따른다.
  - 문자열 타입
  - 불리언 타입
    - 논리적 참과 거짓
  - `undefined` 타입
    - 변수 초기화(자바스크립트 엔진에 의한)에 사용되는 값
    - 개발자가 의도적으로 `undefined`를 사용한다면 `undefined` 본래 취지와 어긋나고 혼란을 줄 수 있다.
  - `null` 타입
    - 변수에 값이 없다는 것을 명시하고 싶을 때 사용하는 값
- 객체 타입

&nbsp;

### 심벌 타입은 뭐죠?

- 다른 값과 중복되지 않는 유일무이한 값
- 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
- 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는다.

```js
var key = Symbol("key");
console.log(typeof key); // symbol

var obj = {};

obj[key] = "value";
console.log(obj[key]); // value
```

&nbsp;

### 데이터 타입은 왜 필요할까요?

- 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
- 값을 참조할 때 한 번에 읽어 들어야 할 **메모리 공간의 크기**를 결정하기 위해
- 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해

> ![TIP]
> 컴파일러 또는 인터프리터는 심벌 테이블이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

&nbsp;

### 정적 타이핑이 뭔가요?

- 모든 변수의 타입이 컴파일타임에 결정된다.
  - 코드 수준에서 개발자가 타입을 명시해줘야 한다.
  - 컴파일타임에 타입 에러를 발견할 수 있기 때문에 프로그램의 안정성을 보장할 수 있다.

&nbsp;

### 동적 타이핑이 뭔가요?

- 변수 타입이 런타임에서 결정된다.
  - 직접 타입을 정의할 필요가 없다.
  - 프로그램을 실행할 때 타입 에러가 발견되므로 언제 프로그램에 오류가 생길지 모르는 불안감에 휩싸이게 된다.

&nbsp;

## 타입 변환과 단축 평가

### 명시적 타입 변환이 뭔가요?

- 타입 캐스팅
- 개발자가 의도적으로 값의 타입을 변환하는 것

&nbsp;

### 명시적 타입 변환 함수를 예를 들어볼 수 있나요?

- `Number`, `String`, `Boolean` 등 빌트인 메서드
- 산술 연산자를 이용한 암시적 타입 변환을 이용
- `parseInt`, `parseFloat` 등 함수를 이용

```js
// 프로그래머스 - 문자열을 정수로 변환하기
// 숫자로만 이루어진 문자열 n_str이 주어질 때, n_str을 정수로 변환하여 return하도록 solution 함수를 완성해주세요.

const solution = (n_str) => +n_str;
const solution = Number;
```

&nbsp;

### 암묵적 타입 변환이 뭔가요?

- 자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환하는 것
  - 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다.
- 암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다.

&nbsp;

### `truthy`/`falsy`한 값이 뭔가요?

- `boolean` 원시 값이 아닌, 형 변환을 통해 `true`/`false`로 취급되는 값
- `falsy` 값
  - `false`
  - `undefined`
  - `null`
  - `0`, `-0`
  - `NaN`
  - ``(빈 문자열)
- `truthy` 값
  - `falsy` 값을 제외한 모든 값

&nbsp;

## 배열

### 자바스크립트의 배열은 자료구조의 배열과 같나요?

- 자바스크립트 배열은 배열이 아니다.
- 자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조(밀집 배열)
- 자바스크립트의 배열은 배열의 요소를 위한 각각의 메모리 공간이 동일한 크기를 갖지 않아도 된다.
- 자바스크립트의 배열은 연속적으로 이어져 있지 않을 수도 있다. (희소 배열)
- 자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체
- 자바스크립트의 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, `length` 프로퍼티를 갖는 특수한 객체다.
  - 자바스크립트 배열의 요소는 프로퍼티 값
- 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없다.
  - 하지만 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.
- 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화해 구현했다.

&nbsp;

### 배열의 메서드는 어떤 종류가 있나요?

- `Array.isArray`: 정적 메서드. 전달된 인수가 배열이면 `true`, 아니면 `false` 반환
- `Array.prototype.indexOf`: 인수로 전달된 요소를 검색하여 인덱스를 반환
- `Array.prototype.push`: 인수로 전달받은 모든 값을 **원본 배열**의 마지막 요소로 추가하고 변경된 `length` 프로퍼티 값을 반환
- `Array.prototype.pop`: **원본 배열**에서 마지막 요소를 제거하고 제거한 요소를 반환
- `Array.prototype.unshift`: 인수로 전달받은 모든 값을 **원본 배열**의 선두에 요소로 추가하고 변경된 `length` 프로퍼티 값을 반환
- `Array.prototype.shift`: **원본 배열**에서 첫 번째 요소를 제거하고 제거한 요소를 반환
- `Array.prototype.concat`: 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 **새로운 배열**을 반환
- `Array.prototype.splice`: 원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는 경우 사용. **원본 배열** 변경
- `Array.prototype.slice`: 인수로 전달된 범위의 요소들을 복사하여 **새로운 배열**로 반환
- `Array.prototype.join`: 원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열, 즉 **구분자로 연결한 문자열**을 반환
- `Array.prototype.reverse`: 원본 배열의 순서를 반대로 뒤집는다. **원본 배열** 변경
- `Array.prototype.fill`: 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다. **원본 배열** 변경
- `Array.prototype.includes`: 배열 내에 특정 요소가 포함되어 있는지 확인하여 `true` 또는 `false` 반환
- `Array.prototype.flat`: 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화

&nbsp;

### 고차 함수에 대해서 아나요?

- 함수를 인수로 전달받거나 함수를 반환하는 함수
- 자바스크립트 함수는 일급 객체이므로 함수를 값처럼 인수로 전달하거나 반환할 수 있다.
- 고차 함수는 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.

&nbsp;

### `forEach` 메서드와 `map` 메서드의 차이점에 대해 알고 있나요?

- `Array.prototype.forEach`: `for` 문을 대체할 수 있는 고차 함수
  - 자신의 내부에서 반복문을 실행
  - 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출
  - `forEach` 메서드의 반환값은 언제나 `undefined`
- `Array.prototype.map`: 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출
  - 콜백 함수의 반환값들로 구성된 새로운 배열을 반환

&nbsp;

## 객체 리터럴

### 자바스크립트에서 객체란 뭘까요?

- 원시 값을 제외한 나머지 값
- 자바스크립트는 객체 기반의 프로그래밍 언어로 자바스크립트를 구성하는 거의 모든 것이 객체다.
- 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성
  - 프로퍼티: 객체의 상태를 나타내는 값
  - 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작

&nbsp;

### 함수와 메서드의 차이점에 대해 알고 계신가요?

- 함수는 일급 객체이기 때문에 값으로 취급할 수 있다.
- 프로퍼티 값이 함수일 경우에 메서드라고 부른다.
- 함수는 독립적으로 존재/호출할 수 있지만, 메서드는 객체에 종속된다.
- 메서드는 `this`를 사용해서 객체 안의 프로퍼티들을 참조할 수 있다.
- 함수는 `this`가 호출한 시점에 바인딩된다.

&nbsp;

### 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?

- 객체 리터럴
- `Object` 생성자 함수
- 생성자 함수
- `Object.create` 메서드
- 클래스(ES6)

&nbsp;

## 원시 값과 객체 비교

### 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요?

- 원시 타입의 값은 변경 불가능한 값이다. 이에 비해 객체 타입의 값은 변경 가능한 값이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장되지만, 객체를 변수에 할당하면 변수에 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달되지만, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.

&nbsp;

### 값에 의한 전달이 뭔가요?

- 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다.
- 다른 메모리 공간에 저장된 별개의 값
  - 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.

&nbsp;

### 참조에 의한 전달이 뭔가요?

- 원본의 참조 값이 복사되어 전달
  - 두 개의 식별자가 하나의 객체를 공유한다.
- 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.

&nbsp;

## 함수

### 자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?

1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수
4. 화살표 함수

&nbsp;

### 함수 선언문과 함수 표현식은 어떤 차이가 있나요?

1. 함수 선언문을 크롬 개발자 도구의 콘솔에서 실행하면 완료 값 `undefined`가 출력된다. 함수 표현식은 표현식이 평가되어 생성된 함수가 출력된다.
2. 함수 선언문은 함수 이름을 생략할 수 없으며, 변수에 할당할 수 없다.
3. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. (함수 표현식)
4. 함수 표현식은 함수 호이스팅이 아닌, 변수 호이스팅을 적용받는다.

&nbsp;

### 즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요.

- 함수 정의와 동시에 즉시 호출되는 함수
- 단 한 번만 호출되며 다시 호출할 수 없다.
- 즉시 실행 함수는 `()`로 반드시 감싸야 한다.
