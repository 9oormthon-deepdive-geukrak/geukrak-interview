## 프로그래밍

### 프로그래밍이란 뭐라고 생각하나요?

- 컴퓨터가 작업을 수행하기 위해 따를 수 있는 프로그램이라는 명령어 순차 조합을 구성하는 것

&nbsp;

### 컴파일러는 뭐고 인터프리터는 뭔가요?

- 컴파일러
  - 프로그램 전체를 스캔해 모두 기계어로 번역
  - 초기 스캔 시간이 오래 걸리지만, 실행 시간은 빠르다.
  - 많은 메모리 사용
    - 고급언어로 작성된 소스를 기계어로 번역(오브젝트 코드)
    - 만들어진 오브젝트 코드를 묶어서 하나의 실행 파일로 제작(링킹)
  - 코드 전체를 검사한 후 오류 메시지를 생성하므로 실행 전에 오류를 발견할 수 있다.
- 인터프리터
  - 프로그램 실행 시 한 번에 한 문장씩 번역
  - 메모리 효율이 좋으나, 실행 시간이 오래 걸린다.
  - 오류를 만나면 프로그램을 중지한다.

&nbsp;

## 자바스크립트란

### 자바스크립트의 특징은 뭐가 있나요?

- 웹 브라우저에서 동작하는 프로그래밍 언어
  - HTML, CSS와 함께 웹을 구성
- 인터프리터 언어
  - 개발자가 별도의 컴파일 작업을 수행하지 않는다.
  - 크롬의 V8 등의 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결
- 멀티 패러다임 프로그래밍 언어
  - 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원
- 프로토타입 기반의 객체지향 언어

&nbsp;

## 변수

### 변수란 무엇인가요?

- 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념
- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 값의 위치를 가리키는 상징적인 이름
  - 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행
- 사람이 이해할 수 잇는 언어로 명명한 변수 이름을 통해 변수에 저장된 값의 의미를 명확히 할 수 있다.

&nbsp;

### 식별자란 무엇인가요?

- 변수 이름
- 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 값은 메모리 공간에 저장돼 있고, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해 낼 수 있어야 한다.
  - 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야 한다.
  - 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.
  - 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
- 변수 이름에만 국한해서 사용하지 않으며, 변수, 함수, 클래스 등의 이름은 모두 식별자이다.
- 네이밍 규칙을 준수해야 한다.

&nbsp;

### 변수를 선언한다는 것은 어떤 것을 의미하나요?

- 변수를 생성하는 것을 의미
- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것
- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용 가능
- 변수 선언의 두 단계
  1. 선언: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
  2. 초기화 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화
- 변수 이름은 실행 컨텍스트에 등록된다.
  - 실행 컨텍스트: 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
  - 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리

&nbsp;

### `var` 키워드는 뭔가요?

- ES6 이전, 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드
- 자바스크립트 엔진에 의해 암묵적으로 `undefined` 값이 할당되어 초기화된다.

&nbsp;

### 호이스팅이 뭔가요?

- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 변수 선언(선언과 초기화)이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행
- `var`, `let`, `const`, `function`, `function*`, `class` 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.
- 값의 할당은 런타임에 실행된다.

&nbsp;

### `var` 키워드의 문제점은 무엇이 있나요?

- 함수 스코프
  - `var` 키워드로 정의된 변수는 함수 스코프이기 때문에, 함수를 벗어난 영역에서 사용하면 에러가 발생한다.
  - 함수 안에서 `var` 키워드를 사용하지 않고 변수에 값을 할당하면 그 변수는 전역변수가 된다.
    - 전역 변수가 되는 것을 피하기 위해서 파일의 최상단에 `use strict`를 사용한다. → 명시적으로 Reference Error가 발생한다.
  - `var`는 함수 스코프이기 때문에 `for`문, `if`문, `while`문 등에서 정의된 변수가 코드 실행이 완료된 후에도 계속 남아있게 되어 접근할 수 있다.
    - 즉시 실행 함수를 사용해 변수의 스코프를 제한할 수 있지만, 좋지 못한 코드가 된다.
  - 전역 공간인 `global`, `window` 등을 오염시키기도 한다.
- 호이스팅
  - JavaScript의 호이스팅은 직관적이지 않으며, 보통의 프로그래밍 언어에서는 찾아보기 힘든 기능이다.
  - 호이스팅된 `var` 변수는 `undefined`가 할당되며 실제 값은 원래 정의했던 위치에서 할당된다.
  - 변수가 정의된 곳 위에서 값을 할당할 수도 있다.
- 재정의
  - `var`를 이용하면 한 번 정의된 변수를 재정의할 수 있다.
- 재할당
  - 재할당 가능한 변수만 만들 수 있다. → 상수처럼 쓰여야하는 값도 재할당이 가능한 값으로 정의된다.

&nbsp;

### `let` 키워드는 `var` 키워드와 어떤 점이 다른가요?

- 블록 스코프
  - 많은 언어에서 블록 스코프를 사용한다.
  - 블록(`{}`) 바깥에서 사용하려고 하면 에러가 발생한다.
  - `const`와 `let`을 사용해서 동일한 이름의 변수를 정의하여 사용하는 경우, 우선순위에 따라 가장 가까운 변수를 사용하게 된다.
- 호이스팅
  - 변수를 정의하기 전에 그 변수를 사용하려고 하면 참조 에러가 발생한다.
  - 호이스팅 이후에 초기화하지 않는다. (TDZ)
- 재정의
  - `let`으로 정의된 변수는 재정의되지 않는다.

&nbsp;

### TDZ

- 일시적 사각지대
- 변수는 선언, 초기화, 할당의 3단계에 걸쳐 생성된다.
  - 선언: 변수를 실행 컨텍스트의 변수 객체에 등록하는 단계
  - 초기화: 실행 컨텍스트에 존재하는 변수 객체에 선언 단계의 변수를 위한 메모리를 만드는 단계
  - 할당: 사용자가 `undefined`로 초기화된 메모리의 값을 다른 값으로 할당하는 단계
- `var`로 선언된 변수는 선언과 초기화가 동시에 이루어진다.
- `let`, `const`로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.

  - 실행 컨텍스트에 변수를 등록했지만, 메모리가 할당되지 않아 접근이 불가능하다.
  - V8 엔진 코드

    ```c
    // var
    var->AllocateTo(VariableLocation::PARAMETER, index);

    // const
    VariableProxy* proxy =
        DeclareBoundVariable(local_name, VariableMode::kConst, pos);
    proxy->var()->set_initializer_position(position());

    // let
    VariableProxy* proxy =
        DeclareBoundVariable(variable_name, VariableMode::kLet, class_token_pos);
    proxy->var()->set_initializer_position(end_pos);
    ```

    - `var`와는 달리 `let`, `const`는 `set_initializer_position` 메소드를 통해 해당 코드의 위치를 의미하는 position 값만 정해준다.
    - 선언은 되어 있지만 변수에 값을 담기 위한 메모리에 공간이 확보되지 않은 상태

&nbsp;

### `const` 키워드는 어떤 특징이 있나요?

- `let`과 동일한 특징을 갖으나, 재할당되지 않는다.
  - **재할당**만 되지 않을 뿐, `const`로 정의된 객체의 내부 속성값은 수정이 가능하다.

&nbsp;

### 식별자 네이밍 규칙은 어떤 것들이 있나요?

- 특수문자를 제외한 문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)를 포함할 수 있다.
- 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

&nbsp;

### 네이밍 컨벤션은 어떤 것들이 있나요?

- 일반적인 네이밍 컨벤션
  - 변수나 함수 이름에는 카멜 케이스 사용
    - camelCase
  - 생성자 함수, 클래스의 이름에는 파스칼 케이스 사용
    - PascalCase
- 다른 언어의 네이밍 컨벤션
  - DB에서 변수명, 함수명, 데이터 타입 등에 스네이크 케이스 사용
    - snake_case
  - url, HTML, CSS 등에서 케밥 케이스 사용
    - kebab-case
  - 상수를 표현할 때 사용하는 스크림 스네이크 케이스
    - SCREAM_SNAKE_CASE
  - 변수나 함수 이름 앞에 타입 접두사를 붙이는 헝가리안 표기법
    - strHungarian

&nbsp;

### 리터럴이 뭔가요?

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법
- 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.
  - 값을 생성하기 위해 미리 약속한 표기법
- 리터럴의 종류
  - 정수 리터럴
  - 부동소수점 리터럴
  - 2진수 리터럴
  - 8진수 리터럴
  - 16진수 리터럴
  - 문자열 리터럴
  - 불리언 리터럴
  - `null` 리터럴
  - `undefined` 리터럴
  - 객체 리터럴
  - 배열 리터럴
  - 함수 리터럴
  - 정규 표현식 리터럴
